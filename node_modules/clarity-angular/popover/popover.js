/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/*
 * Do NOT Angular this up. It assumes we're in the DOM, plays with native elements, ...
 * It could potentially be used as part of clarity-ui as a vanilla Javascript helper.
 *
 * WARNING: This is a quick prototype version, use at your own risks.
 */
export var Direction;
(function (Direction) {
    Direction[Direction["RIGHT"] = 0] = "RIGHT";
})(Direction || (Direction = {}));
var POSITION_RELATIVE = "relative";
var POSITION_ABSOLUTE = "absolute";
var POSITION_FIXED = "fixed";
var OVERFLOW_SCROLL = "scroll";
var OVERFLOW_AUTO = "auto";
var OVERFLOW_HIDDEN = {
    both: "hidden",
    x: "hidden",
    y: "hidden"
};
export var Popover = (function () {
    function Popover(element) {
        this.element = element;
        /*
         * We prevent the containers up to the first positioned one from scrolling
         */
        this.originalOverflows = [];
        // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
        element.style.position = POSITION_ABSOLUTE;
        element.style.top = 0;
        element.style.left = 0;
    }
    Popover.prototype.anchor = function (anchor, direction, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.userAnchorParent, userAnchorParent = _e === void 0 ? false : _e;
        // TODO: we are assuming here that the popover is inside or next to the anchor.
        // We'd need to go up the popover tree too otherwise
        this.preventScrolling(anchor);
        if (userAnchorParent) {
            anchor = anchor.parentNode;
        }
        var anchorRect = anchor.getBoundingClientRect();
        var popoverRect = this.element.getBoundingClientRect();
        var leftDiff;
        var topDiff;
        // TODO: obviously, handle direction
        switch (direction) {
            case Direction.RIGHT:
                leftDiff = anchorRect.left + anchorRect.width - popoverRect.left + offsetX;
                topDiff = anchorRect.top + anchorRect.height / 2 - popoverRect.top - popoverRect.height / 2 + offsetY;
                break;
            default:
        }
        this.element.style.transform = "translateX(" + leftDiff + "px) translateY(" + topDiff + "px)";
    };
    Popover.prototype.destroy = function () {
        this.resumeScrolling();
    };
    Popover.prototype.isPositioned = function (container) {
        var position = getComputedStyle(container).position;
        return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
    };
    Popover.prototype.preventScrolling = function (e) {
        var current = e;
        while (current && current !== document) {
            if (this.scrolls(current)) {
                this.originalOverflows.push({
                    e: current,
                    overflow: this.getInlineOverflow(current)
                });
                this.setInlineOverflow(current, OVERFLOW_HIDDEN);
            }
            if (this.isPositioned(current)) {
                break;
            }
            current = current.parentNode;
        }
    };
    Popover.prototype.resumeScrolling = function () {
        for (var _i = 0, _a = this.originalOverflows; _i < _a.length; _i++) {
            var container = _a[_i];
            this.setInlineOverflow(container.e, container.overflow);
        }
        this.originalOverflows.length = 0;
    };
    Popover.prototype.getInlineOverflow = function (container) {
        return {
            both: container.style.overflow,
            x: container.style.overflowX,
            y: container.style.overflowY
        };
    };
    Popover.prototype.setInlineOverflow = function (container, overflow) {
        container.style.overflow = overflow.both;
        container.style.overflowX = overflow.x;
        container.style.overflowY = overflow.y;
    };
    Popover.prototype.scrolls = function (container) {
        var computedStyles = getComputedStyle(container);
        return computedStyles.overflowX === OVERFLOW_SCROLL || computedStyles.overflowX === OVERFLOW_AUTO
            || computedStyles.overflowY === OVERFLOW_SCROLL || computedStyles.overflowY === OVERFLOW_AUTO;
    };
    return Popover;
}());
//# sourceMappingURL=popover.js.map