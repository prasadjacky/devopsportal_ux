var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Component, Input, ViewChild, Renderer, EventEmitter, Output } from "@angular/core";
import { CustomFilter } from "../../providers/custom-filter";
import { DatagridFilter } from "../../datagrid-filter";
import { DatagridStringFilterImpl } from "./datagrid-string-filter-impl";
import { DatagridFilterRegistrar } from "../../utils/datagrid-filter-registrar";
import { FiltersProvider, RegisteredFilter } from "../../providers/filters";
export var DatagridStringFilter = (function (_super) {
    __extends(DatagridStringFilter, _super);
    function DatagridStringFilter(renderer, filters) {
        _super.call(this, filters);
        this.renderer = renderer;
        /**
         * Indicates if the filter dropdown is open
         */
        this.open = false;
        this.filterValueChange = new EventEmitter();
    }
    Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
        /**
         * Customizable filter logic based on a search text
         */
        set: function (value) {
            if (value instanceof RegisteredFilter) {
                this.setFilter(value);
            }
            else {
                this.setFilter(new DatagridStringFilterImpl(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridStringFilter.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.filterContainer.openChanged.subscribe(function (open) {
            if (open) {
                // We need the timeout because at the time this executes, the input isn't
                // displayed yet.
                setTimeout(function () {
                    _this.renderer.invokeElementMethod(_this.input.nativeElement, "focus");
                });
            }
        });
    };
    Object.defineProperty(DatagridStringFilter.prototype, "value", {
        /**
         * Common setter for the input value
         */
        get: function () {
            return this.filter.value;
        },
        set: function (value) {
            if (!this.filter) {
                return;
            }
            if (!value) {
                value = "";
            }
            if (value !== this.filter.value) {
                this.filter.value = value;
                this.filterValueChange.emit(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridStringFilter.prototype.close = function () {
        this.open = false;
    };
    DatagridStringFilter.decorators = [
        { type: Component, args: [{
                    selector: "clr-dg-string-filter",
                    providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                    template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <!--\n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular\n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" *ngIf=\"open\"\n                (keyup.enter)=\"close()\" (keyup.escape)=\"close()\"/>\n        </clr-dg-filter>\n    "
                },] },
    ];
    /** @nocollapse */
    DatagridStringFilter.ctorParameters = function () { return [
        { type: Renderer, },
        { type: FiltersProvider, },
    ]; };
    DatagridStringFilter.propDecorators = {
        'customStringFilter': [{ type: Input, args: ["clrDgStringFilter",] },],
        'input': [{ type: ViewChild, args: ["input",] },],
        'filterContainer': [{ type: ViewChild, args: [DatagridFilter,] },],
        'value': [{ type: Input, args: ["clrFilterValue",] },],
        'filterValueChange': [{ type: Output, args: ["clrFilterValueChange",] },],
    };
    return DatagridStringFilter;
}(DatagridFilterRegistrar));
//# sourceMappingURL=datagrid-string-filter.js.map