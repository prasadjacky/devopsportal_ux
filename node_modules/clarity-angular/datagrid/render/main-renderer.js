import { Directive, ContentChildren } from "@angular/core";
import { DomAdapter } from "./dom-adapter";
import { DatagridRenderOrganizer } from "./render-organizer";
import { DatagridHeaderRenderer } from "./header-renderer";
import { DatagridRowRenderer } from "./row-renderer";
export var DatagridMainRenderer = (function () {
    function DatagridMainRenderer(organizer) {
        var _this = this;
        this.organizer = organizer;
        this._subscriptions = [];
        /**
         * Indicates if we want to re-compute columns width. This should only happen:
         * 1) When headers change, with columns being added or removed
         * 2) When rows are lazily loaded for the first time
         */
        this.columnsSizesStable = false;
        this._subscriptions.push(organizer.computeWidths.subscribe(function () { return _this.computeHeadersWidth(); }));
    }
    /*
     * Are directives even allowed to do that?
     * It works because it's always attached on the same element as a component since they share the same selector,
     * but it feels like cheating.
     */
    DatagridMainRenderer.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._subscriptions.push(this.headers.changes.subscribe(function () {
            // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
            _this.columnsSizesStable = false;
            _this.stabilizeColumns();
        }));
        this._subscriptions.push(this.rows.changes.subscribe(function () {
            _this.stabilizeColumns();
        }));
    };
    DatagridMainRenderer.prototype.ngAfterViewInit = function () {
        this.stabilizeColumns();
    };
    DatagridMainRenderer.prototype.ngOnDestroy = function () {
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * Makes each header compute its width.
     */
    DatagridMainRenderer.prototype.computeHeadersWidth = function () {
        var _this = this;
        this.headers.forEach(function (header, index) {
            var width = header.computeWidth();
            _this.organizer.widths[index] = { px: width, strict: !!header.strictWidth };
        });
    };
    /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     */
    DatagridMainRenderer.prototype.stabilizeColumns = function () {
        if (this.columnsSizesStable) {
            return;
        }
        // No point resizing if there are no rows, we wait until they are actually loaded.
        if (this.rows.length > 0) {
            this.organizer.resize();
            this.columnsSizesStable = true;
        }
    };
    DatagridMainRenderer.decorators = [
        { type: Directive, args: [{
                    selector: "clr-datagrid",
                    providers: [DomAdapter]
                },] },
    ];
    /** @nocollapse */
    DatagridMainRenderer.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer, },
    ]; };
    DatagridMainRenderer.propDecorators = {
        'headers': [{ type: ContentChildren, args: [DatagridHeaderRenderer,] },],
        'rows': [{ type: ContentChildren, args: [DatagridRowRenderer,] },],
    };
    return DatagridMainRenderer;
}());
//# sourceMappingURL=main-renderer.js.map