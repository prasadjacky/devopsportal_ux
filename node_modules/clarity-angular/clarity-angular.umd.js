(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/forms'), require('@angular/core'), require('rxjs/Subject'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/forms', '@angular/core', 'rxjs/Subject', '@angular/platform-browser'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.clarity = global.ng.clarity || {}),global.ng.common,global.ng.forms,global.ng.core,global.rxjs.Subject,global.ng.platformBrowser));
}(this, (function (exports,_angular_common,_angular_forms,_angular_core,rxjs_Subject,_angular_platformBrowser) { 'use strict';

var Alert = (function () {
    function Alert() {
        this.isSmall = false;
        this.type = "alert-info";
        this.closable = true;
        this.isAppLevel = false;
        this._closed = false;
        this._closedChanged = new _angular_core.EventEmitter(false);
        this.alertTypes = ["alert-info", "alert-warning", "alert-danger", "alert-success"];
    }
    Alert.prototype.close = function () {
        if (!this.closable) {
            return;
        }
        this._closed = true;
        this._closedChanged.emit(true);
    };
    Alert.prototype.open = function () {
        this._closed = false;
        this._closedChanged.emit(false);
    };
    Object.defineProperty(Alert.prototype, "alertType", {
        get: function () {
            if (this.alertTypes.indexOf(this.type) > -1) {
                return this.type;
            }
            return "alert-info";
        },
        enumerable: true,
        configurable: true
    });
    Alert.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-alert",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <div\n          *ngIf=\"!_closed\"\n          class=\"alert\"\n          [ngClass]=\"alertType\"\n          [class.alert-sm]=\"isSmall\"\n          [class.alert-app-level]=\"isAppLevel\">\n          <button type=\"button\" class=\"close\" aria-label=\"Close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon aria-hidden=\"true\" shape=\"close\"></clr-icon>\n          </button>\n          <ng-content select=\".alert-item\"></ng-content>\n      </div>\n    "
                } ] } ];
    /** @nocollapse */
    Alert.ctorParameters = function () { return []; };
    Alert.propDecorators = {
        'isSmall': [{ type: _angular_core.Input, args: ["clrAlertSizeSmall" ] } ],
        'type': [{ type: _angular_core.Input, args: ["clrAlertType" ] } ],
        'closable': [{ type: _angular_core.Input, args: ["clrAlertClosable" ] } ],
        'isAppLevel': [{ type: _angular_core.Input, args: ["clrAlertAppLevel" ] } ],
        '_closed': [{ type: _angular_core.Input, args: ["clrAlertClosed" ] } ],
        '_closedChanged': [{ type: _angular_core.Output, args: ["clrAlertClosedChange" ] } ],
    };
    return Alert;
}());

var ALERT_DIRECTIVES = [
    Alert
];

/**
 * Private counter to generate unique IDs for the checkboxes, to bind the labels to them.
 */
var latestId = 0;
var Checkbox = (function () {
    function Checkbox() {
        // If our host has an ID attribute, we use this instead of our index.
        this._id = (latestId++).toString();
        // If our host has a name attribute, we apply it to the checkbox.
        this.name = null;
        // If the host is disabled we apply it to the checkbox
        this.disabled = false;
        // Support for inline checkboxes, adds the necessary class to the host
        this.inline = false;
        this._checked = false;
        this._indeterminate = false;
        this.indeterminateChange = new _angular_core.EventEmitter(false);
        this.change = new _angular_core.EventEmitter(false);
        /*
         * These callbacks will be given to us through the ControlValueAccessor interface,
         * and we need to call them when the user interacts with the checkbox.
         */
        this.onChangeCallback = function (_) { };
        this.onTouchedCallback = function () { };
    }
    Object.defineProperty(Checkbox.prototype, "id", {
        get: function () {
            return "clr-checkbox-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "checked", {
        get: function () {
            return this._checked;
        },
        set: function (value) {
            if (value !== this._checked) {
                this.indeterminate = false;
                this._checked = value;
                this.change.emit(this.checked);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "indeterminate", {
        get: function () {
            return this._indeterminate;
        },
        set: function (value) {
            if (this._indeterminate !== value) {
                this.checked = false;
                this._indeterminate = value;
                this.indeterminateChange.emit(this._indeterminate);
            }
        },
        enumerable: true,
        configurable: true
    });
    Checkbox.prototype.toggle = function () {
        this.checked = !this.checked;
        this.onChangeCallback(this.checked);
    };
    Checkbox.prototype.writeValue = function (value) {
        if (value === null) {
            value = false;
        }
        if (value !== this.checked) {
            this.checked = value;
        }
    };
    Checkbox.prototype.registerOnChange = function (onChange) {
        this.onChangeCallback = onChange;
    };
    Checkbox.prototype.registerOnTouched = function (onTouched) {
        this.onTouchedCallback = onTouched;
    };
    Checkbox.prototype.touch = function () {
        this.onTouchedCallback();
    };
    Checkbox.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-checkbox",
                    template: "\n        <input type=\"checkbox\" [id]=\"id\" [name]=\"name\" [checked]=\"checked\" \n               [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n               (change)=\"toggle()\" (blur)=\"touch()\">\n        <label [attr.for]=\"id\"><ng-content></ng-content></label>\n    ",
                    host: {
                        "[class.checkbox]": "!inline",
                        "[class.checkbox-inline]": "inline",
                        "[class.disabled]": "disabled"
                    },
                    /*
                     * This provider lets us declare our checkbox as a ControlValueAccessor,
                     * which allows us to use [(ngModel)] directly on our component,
                     * with all the automatic features wiring that come with it.
                     */
                    providers: [{
                            provide: _angular_forms.NG_VALUE_ACCESSOR,
                            useExisting: _angular_core.forwardRef(function () { return Checkbox; }),
                            multi: true
                        }]
                } ] } ];
    /** @nocollapse */
    Checkbox.ctorParameters = function () { return []; };
    Checkbox.propDecorators = {
        '_id': [{ type: _angular_core.Input, args: ["id" ] } ],
        'name': [{ type: _angular_core.Input, args: ["name" ] } ],
        'disabled': [{ type: _angular_core.Input, args: ["clrDisabled" ] } ],
        'inline': [{ type: _angular_core.Input, args: ["clrInline" ] } ],
        '_checked': [{ type: _angular_core.Input, args: ["clrChecked" ] } ],
        'indeterminate': [{ type: _angular_core.Input, args: ["clrIndeterminate" ] } ],
        'indeterminateChange': [{ type: _angular_core.Output, args: ["clrIndeterminateChange" ] } ],
        'change': [{ type: _angular_core.Output, args: ["clrCheckedChange" ] } ],
    };
    return Checkbox;
}());

var CHECKBOX_DIRECTIVES = [
    Checkbox
];

var CodeHighlight = (function () {
    //Had to use renderer because I wanted to add to existing classes on the code block
    //Didn't want to override them completely
    function CodeHighlight(_el, renderer) {
        this._el = _el;
        this.renderer = renderer;
        this._highlight = "";
    }
    CodeHighlight.prototype.ngAfterContentInit = function () {
        this.redraw();
    };
    CodeHighlight.prototype.redraw = function () {
        if (this._el && this._el.nativeElement) {
            Prism.highlightElement(this._el.nativeElement);
        }
    };
    Object.defineProperty(CodeHighlight.prototype, "highlight", {
        get: function () {
            return this._highlight;
        },
        set: function (val) {
            if (val && val.trim() !== "") {
                this._highlight = val;
                this.renderer.setElementClass(this._el.nativeElement, this._highlight, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    CodeHighlight.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "code[clr-code-highlight]"
                } ] } ];
    /** @nocollapse */
    CodeHighlight.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, } ]; };
    CodeHighlight.propDecorators = {
        'highlight': [{ type: _angular_core.Input, args: ["clr-code-highlight" ] } ],
    };
    return CodeHighlight;
}());

var CODE_HIGHLIGHT_DIRECTIVES = [
    CodeHighlight
];

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var CustomFilter = (function () {
    function CustomFilter() {
    }
    return CustomFilter;
}());

var FiltersProvider = (function () {
    function FiltersProvider() {
        /**
         * This subject is the list of filters that changed last, not the whole list.
         * We emit a list rather than just one filter to allow batch changes to several at once.
         */
        this._change = new rxjs_Subject.Subject();
        /**
         * List of all filters, whether they're active or not
         */
        this._all = [];
    }
    Object.defineProperty(FiltersProvider.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    /**
     * Tests if at least one filter is currently active
     */
    FiltersProvider.prototype.hasActiveFilters = function () {
        // We do not use getActiveFilters() because this function will be called much more often
        // and stopping the loop early might be relevant.
        for (var _i = 0, _a = this._all; _i < _a.length; _i++) {
            var filter = _a[_i].filter;
            if (filter && filter.isActive()) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns a list of all currently active filters
     */
    FiltersProvider.prototype.getActiveFilters = function () {
        var ret = [];
        for (var _i = 0, _a = this._all; _i < _a.length; _i++) {
            var filter = _a[_i].filter;
            if (filter && filter.isActive()) {
                ret.push(filter);
            }
        }
        return ret;
    };
    /**
     * Registers a filter, and returns a deregistration function
     */
    FiltersProvider.prototype.add = function (filter) {
        var _this = this;
        var index = this._all.length;
        var subscription = filter.changes.subscribe(function () { return _this._change.next([filter]); });
        var hasUnregistered = false;
        var registered = new RegisteredFilter(filter, function () {
            if (hasUnregistered) {
                return;
            }
            subscription.unsubscribe();
            _this._all.splice(index, 1);
            if (filter.isActive()) {
                _this._change.next([]);
            }
            hasUnregistered = true;
        });
        this._all.push(registered);
        if (filter.isActive()) {
            this._change.next([filter]);
        }
        return registered;
    };
    /**
     * Accepts an item if it is accepted by all currently active filters
     */
    FiltersProvider.prototype.accepts = function (item) {
        for (var _i = 0, _a = this._all; _i < _a.length; _i++) {
            var filter = _a[_i].filter;
            if (filter && filter.isActive() && !filter.accepts(item)) {
                return false;
            }
        }
        return true;
    };
    FiltersProvider.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    FiltersProvider.ctorParameters = function () { return []; };
    return FiltersProvider;
}());
var RegisteredFilter = (function () {
    function RegisteredFilter(filter, unregister) {
        this.filter = filter;
        this.unregister = unregister;
    }
    return RegisteredFilter;
}());

var DatagridFilterRegistrar = (function () {
    function DatagridFilterRegistrar(filters) {
        this.filters = filters;
    }
    Object.defineProperty(DatagridFilterRegistrar.prototype, "filter", {
        get: function () {
            return this.registered && this.registered.filter;
        },
        enumerable: true,
        configurable: true
    });
    DatagridFilterRegistrar.prototype.setFilter = function (filter) {
        // If we previously had another filter, we unregister it
        this.deleteFilter();
        if (filter instanceof RegisteredFilter) {
            this.registered = filter;
        }
        else if (filter) {
            this.registered = this.filters.add(filter);
        }
    };
    
    DatagridFilterRegistrar.prototype.deleteFilter = function () {
        if (this.registered) {
            this.registered.unregister();
            delete this.registered;
        }
    };
    DatagridFilterRegistrar.prototype.ngOnDestroy = function () {
        this.deleteFilter();
    };
    return DatagridFilterRegistrar;
}());

var __extends$1 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * Custom filter that can be added in any column to override the default object property string filter.
 * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
 * since it can be anything (not just a text input).
 */
var DatagridFilter = (function (_super) {
    __extends$1(DatagridFilter, _super);
    function DatagridFilter(_filters) {
        _super.call(this, _filters);
        /**
         * Tracks whether the filter dropdown is open or not
         */
        this._open = false;
        this.openChanged = new _angular_core.EventEmitter(false);
    }
    Object.defineProperty(DatagridFilter.prototype, "open", {
        get: function () {
            return this._open;
        },
        set: function (open) {
            var boolOpen = !!open;
            if (boolOpen !== this._open) {
                this._open = boolOpen;
                this.openChanged.emit(boolOpen);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridFilter.prototype, "customFilter", {
        set: function (filter) {
            this.setFilter(filter);
        },
        enumerable: true,
        configurable: true
    });
    
    Object.defineProperty(DatagridFilter.prototype, "active", {
        /**
         * Indicates if the filter is currently active
         */
        get: function () {
            return !!this.filter && this.filter.isActive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows/hides the filter dropdown
     */
    DatagridFilter.prototype.toggle = function () {
        this.open = !this.open;
    };
    DatagridFilter.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-filter",
                    // We register this component as a CustomFilter, for the parent column to detect it.
                    providers: [{ provide: CustomFilter, useExisting: DatagridFilter }],
                    template: "\n        <button class=\"datagrid-filter-toggle\" (click)=\"toggle()\"\n           [class.datagrid-filter-open]=\"open\" [class.datagrid-filtered]=\"active\"></button>\n\n        <div class=\"datagrid-filter\" *ngIf=\"open\">\n            <!-- FIXME: this whole filter part needs a final design before we can try to have a cleaner DOM -->\n            <div class=\"datagrid-filter-close-wrapper\">\n                <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"open = false\">\n                    <clr-icon aria-hidden=\"true\" shape=\"close\"></clr-icon>\n                </button>\n            </div>\n\n            <ng-content></ng-content>\n        </div>\n    "
                } ] } ];
    /** @nocollapse */
    DatagridFilter.ctorParameters = function () { return [
        { type: FiltersProvider, } ]; };
    DatagridFilter.propDecorators = {
        'open': [{ type: _angular_core.Input, args: ["clrDgFilterOpen" ] } ],
        'openChanged': [{ type: _angular_core.Output, args: ["clrDgFilterOpenChange" ] } ],
        'customFilter': [{ type: _angular_core.Input, args: ["clrDgFilter" ] } ],
    };
    return DatagridFilter;
}(DatagridFilterRegistrar));

var DatagridStringFilterImpl = (function () {
    function DatagridStringFilterImpl(filterFn) {
        this.filterFn = filterFn;
        /**
         * The Observable required as part of the Filter interface
         */
        this._changes = new rxjs_Subject.Subject();
        /**
         * Raw input value
         */
        this._rawValue = "";
        /**
         * Input value converted to lowercase
         */
        this._lowerCaseValue = "";
    }
    Object.defineProperty(DatagridStringFilterImpl.prototype, "changes", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._changes.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    Object.defineProperty(DatagridStringFilterImpl.prototype, "value", {
        get: function () {
            return this._rawValue;
        },
        /**
         * Common setter for the input value
         */
        set: function (value) {
            if (!value) {
                value = "";
            }
            if (value !== this._rawValue) {
                this._rawValue = value;
                this._lowerCaseValue = value.toLowerCase().trim();
                this._changes.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridStringFilterImpl.prototype, "lowerCaseValue", {
        get: function () {
            return this._lowerCaseValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates if the filter is currently active, meaning the input is not empty
     */
    DatagridStringFilterImpl.prototype.isActive = function () {
        return !!this.value;
    };
    /**
     * Tests if an item matches a search text
     */
    DatagridStringFilterImpl.prototype.accepts = function (item) {
        // We always test with the lowercase value of the input, to stay case insensitive
        return this.filterFn.accepts(item, this.lowerCaseValue);
    };
    
    return DatagridStringFilterImpl;
}());

var __extends = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DatagridStringFilter = (function (_super) {
    __extends(DatagridStringFilter, _super);
    function DatagridStringFilter(renderer, filters) {
        _super.call(this, filters);
        this.renderer = renderer;
        /**
         * Indicates if the filter dropdown is open
         */
        this.open = false;
        this.filterValueChange = new _angular_core.EventEmitter();
    }
    Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
        /**
         * Customizable filter logic based on a search text
         */
        set: function (value) {
            if (value instanceof RegisteredFilter) {
                this.setFilter(value);
            }
            else {
                this.setFilter(new DatagridStringFilterImpl(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridStringFilter.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.filterContainer.openChanged.subscribe(function (open) {
            if (open) {
                // We need the timeout because at the time this executes, the input isn't
                // displayed yet.
                setTimeout(function () {
                    _this.renderer.invokeElementMethod(_this.input.nativeElement, "focus");
                });
            }
        });
    };
    Object.defineProperty(DatagridStringFilter.prototype, "value", {
        /**
         * Common setter for the input value
         */
        get: function () {
            return this.filter.value;
        },
        set: function (value) {
            if (!this.filter) {
                return;
            }
            if (!value) {
                value = "";
            }
            if (value !== this.filter.value) {
                this.filter.value = value;
                this.filterValueChange.emit(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridStringFilter.prototype.close = function () {
        this.open = false;
    };
    DatagridStringFilter.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-string-filter",
                    providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                    template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <!--\n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular\n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" *ngIf=\"open\"\n                (keyup.enter)=\"close()\" (keyup.escape)=\"close()\"/>\n        </clr-dg-filter>\n    "
                } ] } ];
    /** @nocollapse */
    DatagridStringFilter.ctorParameters = function () { return [
        { type: _angular_core.Renderer, },
        { type: FiltersProvider, } ]; };
    DatagridStringFilter.propDecorators = {
        'customStringFilter': [{ type: _angular_core.Input, args: ["clrDgStringFilter" ] } ],
        'input': [{ type: _angular_core.ViewChild, args: ["input" ] } ],
        'filterContainer': [{ type: _angular_core.ViewChild, args: [DatagridFilter ] } ],
        'value': [{ type: _angular_core.Input, args: ["clrFilterValue" ] } ],
        'filterValueChange': [{ type: _angular_core.Output, args: ["clrFilterValueChange" ] } ],
    };
    return DatagridStringFilter;
}(DatagridFilterRegistrar));

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Generic accessor for deep object properties
 * that can be specified as simple dot-separated strings.
 */
var NestedProperty = (function () {
    function NestedProperty(prop) {
        this.prop = prop;
        if (prop.indexOf(".") >= 0) {
            this.splitProp = prop.split(".");
        }
    }
    // Safe getter for a deep object property, will not throw an error but return
    // undefined if one of the intermediate properties is null or undefined.
    NestedProperty.prototype.getPropValue = function (item) {
        if (this.splitProp) {
            var value = item;
            for (var _i = 0, _a = this.splitProp; _i < _a.length; _i++) {
                var nestedProp = _a[_i];
                if (value == null || typeof value === "undefined" || typeof value[nestedProp] === "undefined") {
                    return undefined;
                }
                value = value[nestedProp];
            }
            return value;
        }
        else {
            return item[this.prop];
        }
    };
    return NestedProperty;
}());

var DatagridPropertyComparator = (function () {
    function DatagridPropertyComparator(prop) {
        this.prop = prop;
        this.nestedProp = new NestedProperty(prop);
    }
    DatagridPropertyComparator.prototype.compare = function (a, b) {
        var propA = this.nestedProp.getPropValue(a);
        var propB = this.nestedProp.getPropValue(b);
        if (typeof propA === "undefined" || propA === null) {
            if (typeof propB === "undefined" || propB === null) {
                return 0;
            }
            else {
                return 1;
            }
        }
        else {
            if (typeof propB === "undefined" || propB === null) {
                return -1;
            }
            else if (propA < propB) {
                return -1;
            }
            else if (propA > propB) {
                return 1;
            }
            else {
                return 0;
            }
        }
    };
    return DatagridPropertyComparator;
}());

var DatagridPropertyStringFilter = (function () {
    function DatagridPropertyStringFilter(prop, exact) {
        if (exact === void 0) { exact = false; }
        this.prop = prop;
        this.exact = exact;
        this.nestedProp = new NestedProperty(prop);
    }
    DatagridPropertyStringFilter.prototype.accepts = function (item, search) {
        var propValue = this.nestedProp.getPropValue(item);
        if (typeof propValue === "undefined") {
            return false;
        }
        else if (this.exact) {
            return ("" + propValue).toLowerCase() === search;
        }
        else {
            return ("" + propValue).toLowerCase().indexOf(search) >= 0;
        }
    };
    return DatagridPropertyStringFilter;
}());

var Page = (function () {
    function Page() {
        /**
         * Page size, a value of 0 means no pagination
         */
        this._size = 0;
        /**
         * Total items (needed to guess the last page)
         */
        this._totalItems = 0;
        /**
         * The Observable that lets other classes subscribe to page changes
         */
        this._change = new rxjs_Subject.Subject();
        /**
         * Current page
         */
        this._current = 1;
    }
    Object.defineProperty(Page.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (size) {
            var oldSize = this._size;
            if (size !== oldSize) {
                this._size = size;
                // Yeap. That's the formula to keep the first item from the old page still
                // displayed in the new one.
                this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
                // We always emit an event even if the current page index didn't change, because
                // the size changing means the items inside the page are different
                this._change.next(this._current);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "totalItems", {
        get: function () {
            return this._totalItems;
        },
        set: function (total) {
            this._totalItems = total;
            // If we have less items than before, we might need to change the current page
            if (this.current > this.last) {
                this.current = this.last;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "last", {
        get: function () {
            if (this._last) {
                return this._last;
            }
            // If the last page isn't known, we compute it from the last item's index
            if (this.size > 0 && this.totalItems) {
                return Math.ceil(this.totalItems / this.size);
            }
            return 1;
        },
        set: function (page) {
            this._last = page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    Object.defineProperty(Page.prototype, "current", {
        get: function () {
            return this._current;
        },
        set: function (page) {
            if (page !== this._current) {
                this._current = page;
                this._change.next(page);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves to the previous page if it exists
     */
    Page.prototype.previous = function () {
        if (this.current > 1) {
            this.current--;
        }
    };
    /**
     * Moves to the next page if it exists
     */
    Page.prototype.next = function () {
        if (this.current < this.last) {
            this.current++;
        }
    };
    Object.defineProperty(Page.prototype, "firstItem", {
        /**
         * Index of the first item displayed on the current page, starting at 0
         */
        get: function () {
            if (this.size === 0) {
                return 0;
            }
            return (this.current - 1) * this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "lastItem", {
        /**
         * Index of the last item displayed on the current page, starting at 0
         */
        get: function () {
            if (this.size === 0) {
                return this.totalItems - 1;
            }
            var lastInPage = (this.current) * this.size - 1;
            if (this.totalItems) {
                lastInPage = Math.min(lastInPage, this.totalItems - 1);
            }
            return lastInPage;
        },
        enumerable: true,
        configurable: true
    });
    Page.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    Page.ctorParameters = function () { return []; };
    return Page;
}());

var Sort = (function () {
    function Sort() {
        /**
         * Ascending order if false, descending if true
         */
        this._reverse = false;
        /**
         * The Observable that lets other classes subscribe to sort changes
         */
        this._change = new rxjs_Subject.Subject();
    }
    Object.defineProperty(Sort.prototype, "comparator", {
        get: function () {
            return this._comparator;
        },
        set: function (value) {
            this._comparator = value;
            this.emitChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sort.prototype, "reverse", {
        get: function () {
            return this._reverse;
        },
        set: function (value) {
            this._reverse = value;
            this.emitChange();
        },
        enumerable: true,
        configurable: true
    });
    Sort.prototype.emitChange = function () {
        this._change.next(this);
    };
    Object.defineProperty(Sort.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used.
     */
    Sort.prototype.toggle = function (sortBy) {
        // We modify private properties directly, to batch the change event
        if (this.comparator === sortBy) {
            this._reverse = !this._reverse;
        }
        else {
            this._comparator = sortBy;
            this._reverse = false;
        }
        this.emitChange();
    };
    /**
     * Clears the current sorting order
     */
    Sort.prototype.clear = function () {
        this.comparator = null;
    };
    /**
     * Compares two objects according to the current comparator
     */
    Sort.prototype.compare = function (a, b) {
        return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
    };
    Sort.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    Sort.ctorParameters = function () { return []; };
    return Sort;
}());

var Items = (function () {
    function Items(_filters, _sort, _page) {
        this._filters = _filters;
        this._sort = _sort;
        this._page = _page;
        /**
         * Indicates if the data is currently loading
         */
        this.loading = false;
        /**
         * Whether we should use smart items for this datagrid or let the user handle
         * everything.
         */
        this._smart = false;
        /**
         * The Observable that lets other classes subscribe to items changes
         */
        this._change = new rxjs_Subject.Subject();
    }
    /**
     * Cleans up our subscriptions to other providers
     */
    Items.prototype.destroy = function () {
        if (this._filtersSub) {
            this._filtersSub.unsubscribe();
        }
        if (this._sortSub) {
            this._sortSub.unsubscribe();
        }
        if (this._pageSub) {
            this._pageSub.unsubscribe();
        }
    };
    Object.defineProperty(Items.prototype, "smart", {
        get: function () {
            return this._smart;
        },
        enumerable: true,
        configurable: true
    });
    Items.prototype.smartenUp = function () {
        var _this = this;
        this._smart = true;
        /*
         * These observers trigger a chain of function: filter -> sort -> paginate
         * An observer up the chain re-triggers all the operations that follow it.
         */
        this._filtersSub = this._filters.change.subscribe(function () { return _this._filterItems(); });
        this._sortSub = this._sort.change.subscribe(function () {
            // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
            // to get the original order back
            if (!_this._sort.comparator) {
                _this._filterItems();
            }
            else {
                _this._sortItems();
            }
        });
        this._pageSub = this._page.change.subscribe(function () { return _this._changePage(); });
    };
    Object.defineProperty(Items.prototype, "all", {
        set: function (items) {
            if (this.smart) {
                this._all = items;
                this._filterItems();
            }
            else {
                this._displayed = items;
                this.emitChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Manually recompute the list of displayed items
     */
    Items.prototype.refresh = function () {
        if (this.smart) {
            this._filterItems();
        }
    };
    Object.defineProperty(Items.prototype, "displayed", {
        get: function () {
            // Ideally we could return an immutable array, but we don't have it in Clarity yet.
            return this._displayed;
        },
        enumerable: true,
        configurable: true
    });
    Items.prototype.emitChange = function () {
        this._change.next(this.displayed);
    };
    Object.defineProperty(Items.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    Object.defineProperty(Items.prototype, "uninitialized", {
        /**
         * Checks if we don't have data to process yet, to abort early operations
         */
        get: function () {
            return !this._all;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * FiltersProvider items from the raw list
     */
    Items.prototype._filterItems = function () {
        var _this = this;
        if (this.uninitialized) {
            return;
        }
        if (this._filters.hasActiveFilters()) {
            this._filtered = this._all.filter(function (item) { return _this._filters.accepts(item); });
        }
        else {
            // Work on a shallow copy of the array, to not modify the user's model
            this._filtered = this._all.slice();
        }
        this._page.totalItems = this._filtered.length;
        this._sortItems();
    };
    /**
     * Sorts items in the filtered list
     */
    Items.prototype._sortItems = function () {
        var _this = this;
        if (this.uninitialized) {
            return;
        }
        if (this._sort.comparator) {
            this._filtered.sort(function (a, b) { return _this._sort.compare(a, b); });
        }
        this._changePage();
    };
    /**
     * Extracts the current page from the sorted list
     */
    Items.prototype._changePage = function () {
        if (this.uninitialized) {
            return;
        }
        if (this._page.size > 0) {
            this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
        }
        else {
            this._displayed = this._filtered;
        }
        this.emitChange();
    };
    Items.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    Items.ctorParameters = function () { return [
        { type: FiltersProvider, },
        { type: Sort, },
        { type: Page, } ]; };
    return Items;
}());

var DatagridItems = (function () {
    function DatagridItems(template, _differs, _changeDetector, _items) {
        this.template = template;
        this._differs = _differs;
        this._changeDetector = _changeDetector;
        this._items = _items;
        /**
         * Tracking function to identify objects. Default is reference equality.
         */
        this.trackBy = function (index, item) { return item; };
        _items.smartenUp();
    }
    DatagridItems.prototype.ngOnChanges = function (changes) {
        if ("rawItems" in changes) {
            var currentItems = changes["rawItems"].currentValue;
            if (!this._differ && currentItems) {
                this._differ = this._differs.find(currentItems).create(this._changeDetector, this.trackBy);
            }
        }
    };
    DatagridItems.prototype.ngDoCheck = function () {
        if (this._differ) {
            var changes = this._differ.diff(this.rawItems);
            if (changes) {
                // TODO: not very efficient right now,
                // but premature optimization is the root of all evil.
                this._items.all = this.rawItems;
            }
        }
    };
    DatagridItems.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDgItems][clrDgItemsOf]",
                } ] } ];
    /** @nocollapse */
    DatagridItems.ctorParameters = function () { return [
        { type: _angular_core.TemplateRef, },
        { type: _angular_core.IterableDiffers, },
        { type: _angular_core.ChangeDetectorRef, },
        { type: Items, } ]; };
    DatagridItems.propDecorators = {
        'rawItems': [{ type: _angular_core.Input, args: ["clrDgItemsOf" ] } ],
        'trackBy': [{ type: _angular_core.Input, args: ["clrDgItemsTrackBy" ] } ],
    };
    return DatagridItems;
}());

var nbSelection = 0;
var SelectionType;
(function (SelectionType) {
    SelectionType[SelectionType["None"] = 0] = "None";
    SelectionType[SelectionType["Single"] = 1] = "Single";
    SelectionType[SelectionType["Multi"] = 2] = "Multi";
})(SelectionType || (SelectionType = {}));
var Selection = (function () {
    function Selection(_items) {
        var _this = this;
        this._items = _items;
        this._selectionType = SelectionType.None;
        /**
         * Ignore items changes in the same change detection cycle.
         */
        this.debounce = false;
        /**
         * The Observable that lets other classes subscribe to selection changes
         */
        this._change = new rxjs_Subject.Subject();
        this.id = "clr-dg-selection" + (nbSelection++);
        this._itemsSub = _items.change.subscribe(function () {
            if (!_this._selectable || _this.debounce) {
                return;
            }
            /* TODO */
            _this.current.length = 0;
            _this.emitChange();
        });
    }
    Object.defineProperty(Selection.prototype, "selectionType", {
        get: function () {
            return this._selectionType;
        },
        set: function (value) {
            if (value === this.selectionType) {
                return;
            }
            this._selectionType = value;
            if (value === SelectionType.None) {
                delete this.current;
            }
            else {
                this.current = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "_selectable", {
        get: function () {
            return (this._selectionType === SelectionType.Multi) || (this._selectionType === SelectionType.Single);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cleans up our subscriptions to other providers
     */
    Selection.prototype.destroy = function () {
        this._itemsSub.unsubscribe();
    };
    Object.defineProperty(Selection.prototype, "currentSingle", {
        get: function () {
            return this._currentSingle;
        },
        set: function (value) {
            var _this = this;
            if (value === this._currentSingle) {
                return;
            }
            this._currentSingle = value;
            this.emitChange();
            // Ignore items changes in the same change detection cycle.
            this.debounce = true;
            setTimeout(function () { return _this.debounce = false; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "current", {
        get: function () {
            return this._current;
        },
        set: function (value) {
            var _this = this;
            this._current = value;
            this.emitChange();
            // Ignore items changes in the same change detection cycle.
            this.debounce = true;
            setTimeout(function () { return _this.debounce = false; });
        },
        enumerable: true,
        configurable: true
    });
    Selection.prototype.emitChange = function () {
        if (this._selectionType === SelectionType.Single) {
            this._change.next(this.currentSingle);
        }
        else if (this._selectionType === SelectionType.Multi) {
            this._change.next(this.current);
        }
    };
    Object.defineProperty(Selection.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    /**
     * Checks if an item is currently selected
     */
    Selection.prototype.isSelected = function (item) {
        if (this._selectionType === SelectionType.Single) {
            return this.currentSingle === item;
        }
        else if (this._selectionType === SelectionType.Multi) {
            return this.current.indexOf(item) >= 0;
        }
        return false;
    };
    /**
     * Selects or deselects an item
     */
    Selection.prototype.setSelected = function (item, selected) {
        switch (this._selectionType) {
            case SelectionType.None:
                break;
            case SelectionType.Single:
                // in single selection, set currentSingle method should be used
                break;
            case SelectionType.Multi:
                var index = this.current.indexOf(item);
                if (index >= 0 && !selected) {
                    this.current.splice(index, 1);
                    this.emitChange();
                }
                else if (index < 0 && selected) {
                    this.current.push(item);
                    this.emitChange();
                }
                break;
            default:
                break;
        }
    };
    /**
     * Checks if all currently displayed items are selected
     */
    Selection.prototype.isAllSelected = function () {
        if ((this._selectionType !== SelectionType.Multi) || !this._items.displayed) {
            return false;
        }
        var nbDisplayed = this._items.displayed.length;
        return nbDisplayed > 0 && this.current.length === nbDisplayed;
    };
    /**
     * Selects or deselects all currently displayed items
     */
    Selection.prototype.toggleAll = function () {
        var _this = this;
        if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
            return;
        }
        /*
         * If everything is already selected, we clear.
         * If at least one row isn't selected, we select everything.
         */
        if (this.isAllSelected()) {
            this.current.length = 0;
        }
        else {
            this._items.displayed.forEach(function (item) {
                if (_this.current.indexOf(item) < 0) {
                    _this.current.push(item);
                }
            });
        }
        this.emitChange();
    };
    Selection.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    Selection.ctorParameters = function () { return [
        { type: Items, } ]; };
    return Selection;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var DatagridRenderOrganizer = (function () {
    function DatagridRenderOrganizer() {
        this.widths = [];
        this._clearWidths = new rxjs_Subject.Subject();
        this._tableMode = new rxjs_Subject.Subject();
        this._computeWidths = new rxjs_Subject.Subject();
        this._alignColumns = new rxjs_Subject.Subject();
        this.scrollbar = new rxjs_Subject.Subject();
        this.scrollbarWidth = new rxjs_Subject.Subject();
    }
    Object.defineProperty(DatagridRenderOrganizer.prototype, "clearWidths", {
        get: function () {
            return this._clearWidths.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridRenderOrganizer.prototype, "tableMode", {
        get: function () {
            return this._tableMode.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridRenderOrganizer.prototype, "computeWidths", {
        get: function () {
            return this._computeWidths.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridRenderOrganizer.prototype, "alignColumns", {
        get: function () {
            return this._alignColumns.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    DatagridRenderOrganizer.prototype.resize = function () {
        this.widths.length = 0;
        this._clearWidths.next();
        this._tableMode.next(true);
        this._computeWidths.next();
        this._tableMode.next(false);
        this._alignColumns.next();
        this.scrollbar.next();
    };
    DatagridRenderOrganizer.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    DatagridRenderOrganizer.ctorParameters = function () { return []; };
    return DatagridRenderOrganizer;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var RowActionService = (function () {
    function RowActionService(renderOrganizer) {
        this.renderOrganizer = renderOrganizer;
        /**
         * false means no rows with action
         */
        this.hasActionableRow = false;
        /*
         * Ad-hoc dirty lock, handling only a single pending action
         */
        this.locked = false;
    }
    RowActionService.prototype.open = function (fn) {
        if (!this.locked) {
            this.locked = true;
            fn();
            // Scrollbar might have disappeared, we need to warn the renderers
            // TODO: A webkit bug prevents us from simply refreshing the scrollbar. Weird. Needs investigation.
            // this.renderOrganizer.scrollbar.next();
            this.renderOrganizer.resize();
        }
        else {
            this.waiting = fn;
        }
    };
    RowActionService.prototype.close = function () {
        if (this.waiting) {
            this.waiting();
            delete this.waiting;
        }
        else {
            this.locked = false;
            // Scrollbar might have appeared, we need to warn the renderers
            // TODO: A webkit bug prevents us from simply refreshing the scrollbar. Weird. Needs investigation.
            // this.renderOrganizer.scrollbar.next();
            this.renderOrganizer.resize();
        }
    };
    RowActionService.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    RowActionService.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer, } ]; };
    return RowActionService;
}());

var nbRow = 0;
var DatagridRow = (function () {
    function DatagridRow(selection, rowActionService) {
        this.selection = selection;
        this.rowActionService = rowActionService;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        this._selected = false;
        this.selectedChanged = new _angular_core.EventEmitter(false);
        this.id = "clr-dg-row" + (nbRow++);
    }
    Object.defineProperty(DatagridRow.prototype, "selected", {
        /**
         * Indicates if the row is selected
         */
        get: function () {
            if (this.selection.selectionType === SelectionType.None) {
                return this._selected;
            }
            else {
                return this.selection.isSelected(this.item);
            }
        },
        set: function (value) {
            if (this.selection.selectionType === SelectionType.None) {
                this._selected = value;
            }
            else {
                this.selection.setSelected(this.item, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridRow.prototype.toggle = function (selected) {
        if (selected === void 0) { selected = !this.selected; }
        if (selected !== this.selected) {
            this.selected = selected;
            this.selectedChanged.emit(selected);
        }
    };
    DatagridRow.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-row",
                    template: "\n        <clr-dg-cell *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\" class=\"datagrid-select\">\n            <clr-checkbox [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\"></clr-checkbox>\n        </clr-dg-cell>\n        <clr-dg-cell *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\" class=\"datagrid-select\">\n            <div class=\"radio\">\n                <input type=\"radio\" [id]=\"id\"  [name]=\"selection.id + '-radio'\" [value]=\"item\" \n                    [(ngModel)]=\"selection.currentSingle\">    \n                <label for=\"{{id}}\"></label>\n            </div>\n        </clr-dg-cell>\n        <clr-dg-cell *ngIf=\"rowActionService.hasActionableRow\" class=\"datagrid-row-actions\">\n            <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </clr-dg-cell>\n        <ng-content></ng-content>\n    ",
                    host: {
                        "[class.datagrid-row]": "true",
                        "[class.datagrid-selected]": "selected"
                    }
                } ] } ];
    /** @nocollapse */
    DatagridRow.ctorParameters = function () { return [
        { type: Selection, },
        { type: RowActionService, } ]; };
    DatagridRow.propDecorators = {
        'item': [{ type: _angular_core.Input, args: ["clrDgItem" ] } ],
        'selected': [{ type: _angular_core.Input, args: ["clrDgSelected" ] } ],
        'selectedChanged': [{ type: _angular_core.Output, args: ["clrDgSelectedChange" ] } ],
    };
    return DatagridRow;
}());

var DatagridPlaceholder = (function () {
    function DatagridPlaceholder(items, page) {
        this.items = items;
        this.page = page;
    }
    Object.defineProperty(DatagridPlaceholder.prototype, "emptyDatagrid", {
        /**
         * Tests if the datagrid is empty, meaning it doesn't contain any items
         */
        get: function () {
            return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridPlaceholder.prototype, "nbEmptyRows", {
        /**
         * Number of empty rows to display to ensure we preserve a fixed height on the datagrid,
         * even if the last page has less items than the previous ones
         */
        get: function () {
            var rowsDisplayed = 0;
            if (this.items.displayed) {
                rowsDisplayed = this.items.displayed.length;
            }
            // Always leave space for at least 2 rows even if the datagrid isn't paginated
            return Math.max(this.page.size, 2) - rowsDisplayed;
        },
        enumerable: true,
        configurable: true
    });
    DatagridPlaceholder.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-placeholder",
                    template: "\n        <!--\n            I hate doing this, with these 36px being baselineRem(1.5) hardcoded here,\n            but I don't see a better solution right now.\n            \n            TODO: with the new flexbox layout, it might be possible to get rid of this!\n        -->\n        <div class=\"datagrid-placeholder\" [style.min-height]=\"(36*nbEmptyRows)+'px'\"\n            *ngIf=\"nbEmptyRows > 0\" [class.datagrid-empty]=\"emptyDatagrid\">\n            <div class=\"datagrid-placeholder-image\" *ngIf=\"emptyDatagrid\"></div>\n            <ng-content *ngIf=\"emptyDatagrid\"></ng-content>\n        </div>\n    ",
                    host: {
                        "[class.datagrid-placeholder-container]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    DatagridPlaceholder.ctorParameters = function () { return [
        { type: Items, },
        { type: Page, } ]; };
    return DatagridPlaceholder;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/*
 * Do NOT Angular this up. It assumes we're in the DOM, plays with native elements, ...
 * It could potentially be used as part of clarity-ui as a vanilla Javascript helper.
 *
 * WARNING: This is a quick prototype version, use at your own risks.
 */
var Direction;
(function (Direction) {
    Direction[Direction["RIGHT"] = 0] = "RIGHT";
})(Direction || (Direction = {}));
var POSITION_RELATIVE = "relative";
var POSITION_ABSOLUTE = "absolute";
var POSITION_FIXED = "fixed";
var OVERFLOW_SCROLL = "scroll";
var OVERFLOW_AUTO = "auto";
var OVERFLOW_HIDDEN = {
    both: "hidden",
    x: "hidden",
    y: "hidden"
};
var Popover = (function () {
    function Popover(element) {
        this.element = element;
        /*
         * We prevent the containers up to the first positioned one from scrolling
         */
        this.originalOverflows = [];
        // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
        element.style.position = POSITION_ABSOLUTE;
        element.style.top = 0;
        element.style.left = 0;
    }
    Popover.prototype.anchor = function (anchor, direction, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.userAnchorParent, userAnchorParent = _e === void 0 ? false : _e;
        // TODO: we are assuming here that the popover is inside or next to the anchor.
        // We'd need to go up the popover tree too otherwise
        this.preventScrolling(anchor);
        if (userAnchorParent) {
            anchor = anchor.parentNode;
        }
        var anchorRect = anchor.getBoundingClientRect();
        var popoverRect = this.element.getBoundingClientRect();
        var leftDiff;
        var topDiff;
        // TODO: obviously, handle direction
        switch (direction) {
            case Direction.RIGHT:
                leftDiff = anchorRect.left + anchorRect.width - popoverRect.left + offsetX;
                topDiff = anchorRect.top + anchorRect.height / 2 - popoverRect.top - popoverRect.height / 2 + offsetY;
                break;
            default:
        }
        this.element.style.transform = "translateX(" + leftDiff + "px) translateY(" + topDiff + "px)";
    };
    Popover.prototype.destroy = function () {
        this.resumeScrolling();
    };
    Popover.prototype.isPositioned = function (container) {
        var position = getComputedStyle(container).position;
        return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
    };
    Popover.prototype.preventScrolling = function (e) {
        var this$1 = this;

        var current = e;
        while (current && current !== document) {
            if (this$1.scrolls(current)) {
                this$1.originalOverflows.push({
                    e: current,
                    overflow: this$1.getInlineOverflow(current)
                });
                this$1.setInlineOverflow(current, OVERFLOW_HIDDEN);
            }
            if (this$1.isPositioned(current)) {
                break;
            }
            current = current.parentNode;
        }
    };
    Popover.prototype.resumeScrolling = function () {
        var this$1 = this;

        for (var _i = 0, _a = this.originalOverflows; _i < _a.length; _i++) {
            var container = _a[_i];
            this$1.setInlineOverflow(container.e, container.overflow);
        }
        this.originalOverflows.length = 0;
    };
    Popover.prototype.getInlineOverflow = function (container) {
        return {
            both: container.style.overflow,
            x: container.style.overflowX,
            y: container.style.overflowY
        };
    };
    Popover.prototype.setInlineOverflow = function (container, overflow) {
        container.style.overflow = overflow.both;
        container.style.overflowX = overflow.x;
        container.style.overflowY = overflow.y;
    };
    Popover.prototype.scrolls = function (container) {
        var computedStyles = getComputedStyle(container);
        return computedStyles.overflowX === OVERFLOW_SCROLL || computedStyles.overflowX === OVERFLOW_AUTO
            || computedStyles.overflowY === OVERFLOW_SCROLL || computedStyles.overflowY === OVERFLOW_AUTO;
    };
    return Popover;
}());

var DatagridActionOverflow = (function () {
    function DatagridActionOverflow(elementRef, rowActionService) {
        this.elementRef = elementRef;
        this.rowActionService = rowActionService;
        /**
         * Tracks whether the action overflow menu is open or not
         */
        this._open = false;
        this.openChanged = new _angular_core.EventEmitter(false);
    }
    DatagridActionOverflow.prototype.ngAfterViewInit = function () {
        var _this = this;
        this._menuSubscription = this.menu.changes.subscribe(function () {
            if (_this.menu.length > 0) {
                _this.rowActionService.open(function () {
                    _this.position = new Popover(_this.menu.first.nativeElement);
                    _this.position.anchor(_this.elementRef.nativeElement, Direction.RIGHT, { userAnchorParent: true });
                });
            }
            else {
                _this.position.destroy();
                delete _this.position;
                _this.rowActionService.close();
            }
        });
    };
    DatagridActionOverflow.prototype.ngOnDestroy = function () {
        this._menuSubscription.unsubscribe();
    };
    Object.defineProperty(DatagridActionOverflow.prototype, "open", {
        get: function () {
            return this._open;
        },
        set: function (open) {
            var boolOpen = !!open;
            if (boolOpen !== this._open) {
                this._open = boolOpen;
                this.openChanged.emit(boolOpen);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows/hides the action overflow menu
     */
    DatagridActionOverflow.prototype.toggle = function () {
        this.open = !this.open;
    };
    //called on mouse clicks anywhere in the DOM.
    //Checks to see if the mouseclick happened on the host or outside
    DatagridActionOverflow.prototype.onMouseClick = function (target) {
        if (this._open) {
            var current = target; //Get the element in the DOM on which the mouse was clicked
            var actionMenuHost = this.elementRef.nativeElement; //Get the current actionMenu native HTML element
            if (target.className === "datagrid-action-overflow") {
                return; // if clicking on the action overflow container but not the content, return without closing
            }
            //Start checking if current and actionMenuHost are equal. If not traverse to the parentNode and check again.
            while (current) {
                if (current.className === "datagrid-action-overflow") {
                    break; // if user clicked on the overflow menu, hide it
                }
                if (current === actionMenuHost) {
                    return;
                }
                current = current.parentNode;
            }
            this._open = false; // Hide the overflow menu
        }
    };
    DatagridActionOverflow.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-action-overflow",
                    template: "\n        <clr-icon shape=\"ellipsis-vertical\" class=\"datagrid-action-toggle\" (click)=\"toggle()\"></clr-icon>\n        <div #menu class=\"datagrid-action-overflow\" *ngIf=\"open\">\n            <ng-content></ng-content>\n        </div>\n    "
                } ] } ];
    /** @nocollapse */
    DatagridActionOverflow.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: RowActionService, } ]; };
    DatagridActionOverflow.propDecorators = {
        'menu': [{ type: _angular_core.ViewChildren, args: ["menu" ] } ],
        'open': [{ type: _angular_core.Input, args: ["clrDgActionOverflowOpen" ] } ],
        'openChanged': [{ type: _angular_core.Output, args: ["clrDgActionOverflowOpenChange" ] } ],
        'onMouseClick': [{ type: _angular_core.HostListener, args: ["document:click", ["$event.target"] ] } ],
    };
    return DatagridActionOverflow;
}());

var Datagrid = (function () {
    function Datagrid(selection, sort, filters, page, items, rowActionService) {
        this.selection = selection;
        this.sort = sort;
        this.filters = filters;
        this.page = page;
        this.items = items;
        this.rowActionService = rowActionService;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        /**
         * Output emitted whenever the data needs to be refreshed, based on user action or external ones
         */
        this.refresh = new _angular_core.EventEmitter(false);
        this.selectedChanged = new _angular_core.EventEmitter(false);
        this.singleSelectedChanged = new _angular_core.EventEmitter(false);
        /**
         * Subscriptions to all the services and queries changes
         */
        this._subscriptions = [];
    }
    Object.defineProperty(Datagrid.prototype, "loading", {
        /**
         * Freezes the datagrid while data is loading
         */
        get: function () {
            return this.items.loading;
        },
        set: function (value) {
            this.items.loading = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emits a State output to ask for the data to be refreshed
     */
    Datagrid.prototype.triggerRefresh = function () {
        var state$$1 = {};
        if (this.page.size > 0) {
            state$$1.page = {
                from: this.page.firstItem,
                to: this.page.lastItem,
                size: this.page.size
            };
        }
        if (this.sort.comparator) {
            if (this.sort.comparator instanceof DatagridPropertyComparator) {
                /*
                 * Special case for the default object property comparator,
                 * we give the property name instead of the actual comparator.
                 */
                state$$1.sort = {
                    by: this.sort.comparator.prop,
                    reverse: this.sort.reverse
                };
            }
            else {
                state$$1.sort = {
                    by: this.sort.comparator,
                    reverse: this.sort.reverse
                };
            }
        }
        var activeFilters = this.filters.getActiveFilters();
        if (activeFilters.length > 0) {
            state$$1.filters = [];
            for (var _i = 0, activeFilters_1 = activeFilters; _i < activeFilters_1.length; _i++) {
                var filter = activeFilters_1[_i];
                if (filter instanceof DatagridStringFilterImpl) {
                    var stringFilter = filter.filterFn;
                    if (stringFilter instanceof DatagridPropertyStringFilter) {
                        /*
                         * Special case again for the default object property filter,
                         * we give the property name instead of the full filter object.
                         */
                        state$$1.filters.push({
                            property: stringFilter.prop,
                            value: filter.value
                        });
                        continue;
                    }
                }
                state$$1.filters.push(filter);
            }
        }
        this.refresh.emit(state$$1);
    };
    /**
     * Public method to re-trigger the computation of displayed items manually
     */
    Datagrid.prototype.dataChanged = function () {
        this.items.refresh();
    };
    Object.defineProperty(Datagrid.prototype, "selected", {
        /**
         * Array of all selected items
         */
        set: function (value) {
            if (value) {
                this.selection.selectionType = SelectionType.Multi;
            }
            this.selection.current = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Datagrid.prototype, "singleSelected", {
        /**
         * Selected item in single-select mode
         */
        set: function (value) {
            this.selection.selectionType = SelectionType.Single;
            if (value) {
                this.selection.currentSingle = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Datagrid.prototype, "allSelected", {
        /**
         * Indicates if all currently displayed items are selected
         */
        get: function () {
            return this.selection.isAllSelected();
        },
        /**
         * Selects/deselects all currently displayed items
         * @param value
         */
        set: function (value) {
            /*
             * This is a setter but we ignore the value.
             * It's strange, but it lets us have an indeterminate state where only
             * some of the items are selected.
             */
            this.selection.toggleAll();
        },
        enumerable: true,
        configurable: true
    });
    Datagrid.prototype.ngAfterContentInit = function () {
        var _this = this;
        // TODO: Move all this to ngOnInit() once https://github.com/angular/angular/issues/12818 goes in.
        // And when we do that, remove the manual step for each one.
        this._subscriptions.push(this.actionableRows.changes.subscribe(function () {
            /*if at least one row has actionable overflow, show a placeholder cell in every other row.*/
            _this.rowActionService.hasActionableRow = _this.actionableRows.length > 0;
        }));
        this.rowActionService.hasActionableRow = this.actionableRows.length > 0;
        this._subscriptions.push(this.rows.changes.subscribe(function () {
            if (!_this.items.smart) {
                _this.items.all = _this.rows.map(function (row) { return row.item; });
            }
        }));
        if (!this.items.smart) {
            this.items.all = this.rows.map(function (row) { return row.item; });
        }
    };
    /**
     * Our setup happens in the view of some of our components, so we wait for it to be done before starting
     */
    Datagrid.prototype.ngAfterViewInit = function () {
        var _this = this;
        // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
        this.triggerRefresh();
        this._subscriptions.push(this.sort.change.subscribe(function () { return _this.triggerRefresh(); }));
        this._subscriptions.push(this.filters.change.subscribe(function () { return _this.triggerRefresh(); }));
        this._subscriptions.push(this.page.change.subscribe(function () { return _this.triggerRefresh(); }));
        this._subscriptions.push(this.selection.change.subscribe(function (s) {
            if (_this.selection.selectionType === SelectionType.Single) {
                _this.singleSelectedChanged.emit(s);
            }
            else if (_this.selection.selectionType === SelectionType.Multi) {
                _this.selectedChanged.emit(s);
            }
        }));
    };
    Datagrid.prototype.ngOnDestroy = function () {
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    Datagrid.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-datagrid",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <ng-content select=\"clr-dg-action-bar\"></ng-content>\n      <div class=\"datagrid\">\n          <div clrDgTableWrapper class=\"datagrid-table-wrapper\">\n              <div clrDgHead class=\"datagrid-head\">\n                  <div class=\"datagrid-row\">\n                      <!-- header for datagrid where you can select multiple rows -->\n                      <div class=\"datagrid-column datagrid-select\"\n                           *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                              <span class=\"datagrid-column-title\">\n                                  <clr-checkbox [(ngModel)]=\"allSelected\"></clr-checkbox>\n                              </span>\n                      </div>\n                      <!-- header for datagrid where you can select one row only -->\n                      <div class=\"datagrid-column datagrid-select\"\n                           *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n                      </div>\n                      <!-- header for single row action; only display if we have at least one actionable row in datagrid -->\n                      <div class=\"datagrid-column datagrid-row-actions\" *ngIf=\"rowActionService.hasActionableRow\"></div>\n                      <ng-content select=\"clr-dg-column\"></ng-content>\n                  </div>\n              </div>\n\n              <div clrDgBody class=\"datagrid-body\">\n                  <template *ngIf=\"iterator\"\n                            ngFor [ngForOf]=\"items.displayed\" [ngForTrackBy]=\"iterator.trackBy\"\n                            [ngForTemplate]=\"iterator.template\"></template>\n                  <ng-content *ngIf=\"!iterator\"></ng-content>\n              </div>\n          </div>\n\n          <!-- Custom placeholder overrides the default empty one -->\n          <ng-content select=\"clr-dg-placeholder\"></ng-content>\n          <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n\n          <!--\n              This is not inside the table because there is no good way of having a single column span\n              everything when using custom elements with display:table-cell.\n          -->\n          <ng-content select=\"clr-dg-footer\"></ng-content>\n\n          <div class=\"datagrid-spinner\" *ngIf=\"loading\">\n              <div class=\"spinner\">Loading...</div>\n          </div>\n      </div>\n    ",
                    providers: [Selection, Sort, FiltersProvider, Page, RowActionService, Items, DatagridRenderOrganizer],
                    host: {
                        "[class.datagrid-container]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    Datagrid.ctorParameters = function () { return [
        { type: Selection, },
        { type: Sort, },
        { type: FiltersProvider, },
        { type: Page, },
        { type: Items, },
        { type: RowActionService, } ]; };
    Datagrid.propDecorators = {
        'loading': [{ type: _angular_core.Input, args: ["clrDgLoading" ] } ],
        'refresh': [{ type: _angular_core.Output, args: ["clrDgRefresh" ] } ],
        'iterator': [{ type: _angular_core.ContentChild, args: [DatagridItems ] } ],
        'selected': [{ type: _angular_core.Input, args: ["clrDgSelected" ] } ],
        'selectedChanged': [{ type: _angular_core.Output, args: ["clrDgSelectedChange" ] } ],
        'singleSelected': [{ type: _angular_core.Input, args: ["clrDgSingleSelected" ] } ],
        'singleSelectedChanged': [{ type: _angular_core.Output, args: ["clrDgSingleSelectedChange" ] } ],
        'placeholder': [{ type: _angular_core.ContentChild, args: [DatagridPlaceholder ] } ],
        'rows': [{ type: _angular_core.ContentChildren, args: [DatagridRow ] } ],
        'actionableRows': [{ type: _angular_core.ContentChildren, args: [DatagridActionOverflow, { descendants: true } ] } ],
    };
    return Datagrid;
}());

var DatagridActionBar = (function () {
    function DatagridActionBar(selection) {
        this.selection = selection;
    }
    DatagridActionBar.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-action-bar",
                    template: "\n        <ng-content *ngIf=\"selection.current && selection.current.length > 0\"></ng-content>\n    ",
                    host: {
                        "[class.datagrid-action-bar]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    DatagridActionBar.ctorParameters = function () { return [
        { type: Selection, } ]; };
    return DatagridActionBar;
}());

var DatagridCell = (function () {
    function DatagridCell() {
    }
    DatagridCell.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-cell",
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        "[class.datagrid-cell]": "true",
                    }
                } ] } ];
    /** @nocollapse */
    DatagridCell.ctorParameters = function () { return []; };
    return DatagridCell;
}());

var __extends$2 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DatagridColumn = (function (_super) {
    __extends$2(DatagridColumn, _super);
    function DatagridColumn(_sort, filters) {
        var _this = this;
        _super.call(this, filters);
        this._sort = _sort;
        /**
         * Indicates if the column is currently sorted
         */
        this._sorted = false;
        this.sortedChange = new _angular_core.EventEmitter();
        /**
         * A custom filter for this column that can be provided in the projected content
         */
        this.customFilter = false;
        this.filterValueChange = new _angular_core.EventEmitter();
        this._sortSubscription = _sort.change.subscribe(function (sort) {
            // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
            if (_this.sorted && sort.comparator !== _this.sortBy) {
                _this._sorted = false;
                _this.sortedChange.emit(false);
            }
        });
    }
    DatagridColumn.prototype.ngOnDestroy = function () {
        this._sortSubscription.unsubscribe();
    };
    Object.defineProperty(DatagridColumn.prototype, "sortable", {
        /**
         * Indicates if the column is sortable
         */
        get: function () {
            return !!this.sortBy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridColumn.prototype, "sorted", {
        get: function () {
            return this._sorted;
        },
        set: function (value) {
            if (!value && this.sorted) {
                this._sorted = false;
                this._sort.clear();
            }
            else if (value && !this.sorted) {
                this.sort();
            }
        },
        enumerable: true,
        configurable: true
    });
    
    /**
     * Sorts the datagrid based on this column
     */
    DatagridColumn.prototype.sort = function () {
        if (!this.sortable) {
            return;
        }
        this._sorted = true;
        this._sort.toggle(this.sortBy);
        this.sortedChange.emit(true);
    };
    Object.defineProperty(DatagridColumn.prototype, "asc", {
        /**
         * Indicates if the column is currently sorted in ascending order
         */
        get: function () {
            return this.sorted && !this._sort.reverse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridColumn.prototype, "desc", {
        /**
         * Indicates if the column is currently sorted in descending order
         */
        get: function () {
            return this.sorted && this._sort.reverse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridColumn.prototype, "projectedFilter", {
        set: function (custom) {
            if (custom) {
                this.deleteFilter();
                this.customFilter = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridColumn.prototype, "field", {
        get: function () {
            return this._field;
        },
        set: function (field) {
            if (typeof field === "string") {
                this._field = field;
                if (!this.customFilter) {
                    this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
                }
                if (!this.sortBy) {
                    this.sortBy = new DatagridPropertyComparator(field);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridColumn.prototype, "filterValue", {
        get: function () {
            return this.filter.value;
        },
        set: function (newValue) {
            if (!this.filter) {
                return;
            }
            if (!newValue) {
                newValue = "";
            }
            if (newValue !== this.filter.value) {
                this.filter.value = newValue;
                this.filterValueChange.emit(newValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    DatagridColumn.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-column",
                    template: "\n        <div class=\"datagrid-column-flex\">\n            <!-- I'm really not happy with that select since it's not very scalable -->\n            <ng-content select=\"clr-dg-filter, clr-dg-string-filter\"></ng-content>\n\n            <clr-dg-string-filter\n                *ngIf=\"field && !customFilter\"\n                [clrDgStringFilter]=\"registered\"\n                [(clrFilterValue)]=\"filterValue\"></clr-dg-string-filter>\n\n            <button class=\"datagrid-column-title\" [disabled]=\"!sortable\" (click)=\"sort()\">\n                <ng-content></ng-content>\n            </button>\n        </div>\n    ",
                    host: {
                        "[class.datagrid-column]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    DatagridColumn.ctorParameters = function () { return [
        { type: Sort, },
        { type: FiltersProvider, } ]; };
    DatagridColumn.propDecorators = {
        'sortBy': [{ type: _angular_core.Input, args: ["clrDgSortBy" ] } ],
        'sorted': [{ type: _angular_core.Input, args: ["clrDgSorted" ] } ],
        'sortedChange': [{ type: _angular_core.Output, args: ["clrDgSortedChange" ] } ],
        'asc': [{ type: _angular_core.HostBinding, args: ["class.asc" ] } ],
        'desc': [{ type: _angular_core.HostBinding, args: ["class.desc" ] } ],
        'projectedFilter': [{ type: _angular_core.ContentChild, args: [CustomFilter ] } ],
        'field': [{ type: _angular_core.Input, args: ["clrDgField" ] } ],
        'filterValue': [{ type: _angular_core.Input, args: ["clrFilterValue" ] } ],
        'filterValueChange': [{ type: _angular_core.Output, args: ["clrFilterValueChange" ] } ],
    };
    return DatagridColumn;
}(DatagridFilterRegistrar));

var DatagridFooter = (function () {
    function DatagridFooter() {
    }
    DatagridFooter.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-footer",
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        "[class.datagrid-foot]": "true",
                    }
                } ] } ];
    /** @nocollapse */
    DatagridFooter.ctorParameters = function () { return []; };
    return DatagridFooter;
}());

var DatagridPagination = (function () {
    function DatagridPagination(page) {
        var _this = this;
        this.page = page;
        this.currentChanged = new _angular_core.EventEmitter(false);
        /*
         * Default page size is 10.
         * The reason we set it in this constructor and not in the provider itself is because
         * we don't want pagination (page size 0) if this component isn't present in the datagrid.
         */
        page.size = 10;
        this._pageSubscription = page.change.subscribe(function (current) { return _this.currentChanged.emit(current); });
    }
    DatagridPagination.prototype.ngOnDestroy = function () {
        this._pageSubscription.unsubscribe();
    };
    Object.defineProperty(DatagridPagination.prototype, "pageSize", {
        /**
         * Page size
         */
        get: function () {
            return this.page.size;
        },
        set: function (size) {
            if (typeof size === "number") {
                this.page.size = size;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridPagination.prototype, "totalItems", {
        /**
         * Total items (needed to guess the last page)
         */
        get: function () {
            return this.page.totalItems;
        },
        set: function (total) {
            if (typeof total === "number") {
                this.page.totalItems = total;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridPagination.prototype, "lastPage", {
        /**
         * Last page
         */
        get: function () {
            return this.page.last;
        },
        set: function (last) {
            if (typeof last === "number") {
                this.page.last = last;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridPagination.prototype, "currentPage", {
        /**
         * Current page
         */
        get: function () {
            return this.page.current;
        },
        set: function (page) {
            if (typeof page === "number") {
                this.page.current = page;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves to the previous page if it exists
     */
    DatagridPagination.prototype.previous = function () {
        this.page.previous();
    };
    /**
     * Moves to the next page if it exists
     */
    DatagridPagination.prototype.next = function () {
        this.page.next();
    };
    Object.defineProperty(DatagridPagination.prototype, "firstItem", {
        /**
         * Index of the first item displayed on the current page, starting at 0
         */
        get: function () {
            return this.page.firstItem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridPagination.prototype, "lastItem", {
        /**
         * Index of the last item displayed on the current page, starting at 0
         */
        get: function () {
            return this.page.lastItem;
        },
        enumerable: true,
        configurable: true
    });
    DatagridPagination.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dg-pagination",
                    template: "\n        <ul class=\"pagination\" *ngIf=\"page.last > 1\">\n            <li *ngIf=\"page.current > 1\">\n                <button class=\"pagination-previous\" (click)=\"page.previous()\"></button>\n            </li>\n            <li *ngIf=\"page.current > 2\">\n                <button (click)=\"page.current = 1\">1</button>\n            </li>\n            <li *ngIf=\"page.current > 3\">...</li>\n            <li *ngIf=\"page.current > 1\">\n                <button (click)=\"page.previous()\">{{page.current - 1}}</button>\n            </li>\n            <li class=\"pagination-current\">{{page.current}}</li>\n            <li *ngIf=\"page.current < page.last\">\n                <button (click)=\"page.next()\">{{page.current + 1}}</button>\n            </li>\n            <li *ngIf=\"page.current < page.last - 2\">...</li>\n            <li *ngIf=\"page.current < page.last - 1\">\n                <button (click)=\"page.current = page.last\">{{page.last}}</button>\n            </li>\n            <li *ngIf=\"page.current < page.last\">\n                <button class=\"pagination-next\" (click)=\"page.next()\"></button>\n            </li>\n        </ul>\n    ",
                    // IE10 comes to pollute even our components declaration
                    styles: [":host { display: block; }"]
                } ] } ];
    /** @nocollapse */
    DatagridPagination.ctorParameters = function () { return [
        { type: Page, } ]; };
    DatagridPagination.propDecorators = {
        'pageSize': [{ type: _angular_core.Input, args: ["clrDgPageSize" ] } ],
        'totalItems': [{ type: _angular_core.Input, args: ["clrDgTotalItems" ] } ],
        'lastPage': [{ type: _angular_core.Input, args: ["clrDgLastPage" ] } ],
        'currentPage': [{ type: _angular_core.Input, args: ["clrDgPage" ] } ],
        'currentChanged': [{ type: _angular_core.Output, args: ["clrDgPageChange" ] } ],
    };
    return DatagridPagination;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var DomAdapter = (function () {
    function DomAdapter() {
    }
    DomAdapter.prototype.userDefinedWidth = function (element) {
        element.classList.add("datagrid-cell-width-zero");
        var userDefinedWidth = parseInt(getComputedStyle(element).getPropertyValue("width"), 10);
        element.classList.remove("datagrid-cell-width-zero");
        return userDefinedWidth;
    };
    DomAdapter.prototype.scrollBarWidth = function (element) {
        return element.offsetWidth - element.clientWidth;
    };
    DomAdapter.prototype.scrollWidth = function (element) {
        return element.scrollWidth || 0;
    };
    DomAdapter.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    DomAdapter.ctorParameters = function () { return []; };
    return DomAdapter;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var COMPUTE_WIDTH_CLASS = "datagrid-computing-columns-width";
var STRICT_WIDTH_CLASS = "datagrid-fixed-width";

var DatagridHeaderRenderer = (function () {
    function DatagridHeaderRenderer(el, renderer, domAdapter, organizer) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.domAdapter = domAdapter;
        this.widthSet = false;
        this.subscription = organizer.clearWidths.subscribe(function () { return _this.clearWidth(); });
    }
    DatagridHeaderRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridHeaderRenderer.prototype.clearWidth = function () {
        this.renderer.setElementClass(this.el.nativeElement, STRICT_WIDTH_CLASS, false);
        // We only clear if we set the width ourselves, otherwise we risk clearing consumer styles.
        if (this.widthSet) {
            this.renderer.setElementStyle(this.el.nativeElement, "width", null);
            this.widthSet = false;
        }
        var strictWidth = this.domAdapter.userDefinedWidth(this.el.nativeElement);
        if (strictWidth) {
            this.strictWidth = strictWidth;
        }
        else {
            delete this.strictWidth;
        }
    };
    DatagridHeaderRenderer.prototype.computeWidth = function () {
        if (this.strictWidth) {
            // We do NOT set the width here, since we know the user already provided it.
            this.renderer.setElementClass(this.el.nativeElement, STRICT_WIDTH_CLASS, true);
            return this.strictWidth;
        }
        else {
            var width = this.domAdapter.scrollWidth(this.el.nativeElement);
            this.renderer.setElementClass(this.el.nativeElement, STRICT_WIDTH_CLASS, false);
            this.renderer.setElementStyle(this.el.nativeElement, "width", width + "px");
            this.widthSet = true;
            return width;
        }
    };
    DatagridHeaderRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "clr-dg-column"
                } ] } ];
    /** @nocollapse */
    DatagridHeaderRenderer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, },
        { type: DomAdapter, },
        { type: DatagridRenderOrganizer, } ]; };
    return DatagridHeaderRenderer;
}());

var DatagridCellRenderer = (function () {
    function DatagridCellRenderer(el, renderer, organizer) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.subscription = organizer.clearWidths.subscribe(function () { return _this.clearWidth(); });
    }
    DatagridCellRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridCellRenderer.prototype.clearWidth = function () {
        this.renderer.setElementClass(this.el.nativeElement, STRICT_WIDTH_CLASS, false);
        this.renderer.setElementStyle(this.el.nativeElement, "width", null);
    };
    DatagridCellRenderer.prototype.setWidth = function (strict, value) {
        this.renderer.setElementClass(this.el.nativeElement, STRICT_WIDTH_CLASS, strict);
        this.renderer.setElementStyle(this.el.nativeElement, "width", value + "px");
    };
    DatagridCellRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "clr-dg-cell"
                } ] } ];
    /** @nocollapse */
    DatagridCellRenderer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, },
        { type: DatagridRenderOrganizer, } ]; };
    return DatagridCellRenderer;
}());

var DatagridRowRenderer = (function () {
    function DatagridRowRenderer(organizer) {
        var _this = this;
        this.organizer = organizer;
        this.subscription = organizer.alignColumns.subscribe(function () { return _this.setWidths(); });
    }
    DatagridRowRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridRowRenderer.prototype.setWidths = function () {
        var _this = this;
        if (this.organizer.widths.length === 0) {
            return;
        }
        this.cells.forEach(function (cell, index) {
            var width = _this.organizer.widths[index];
            cell.setWidth(width.strict, width.px);
        });
    };
    /*
     * Are directives even allowed to do that?
     * It works because it's always attached on the same element as a component since they share the same selector,
     * but it feels like cheating.
     */
    DatagridRowRenderer.prototype.ngAfterViewInit = function () {
        this.setWidths();
    };
    DatagridRowRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "clr-dg-row"
                } ] } ];
    /** @nocollapse */
    DatagridRowRenderer.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer, } ]; };
    DatagridRowRenderer.propDecorators = {
        'cells': [{ type: _angular_core.ContentChildren, args: [DatagridCellRenderer ] } ],
    };
    return DatagridRowRenderer;
}());

var DatagridMainRenderer = (function () {
    function DatagridMainRenderer(organizer) {
        var _this = this;
        this.organizer = organizer;
        this._subscriptions = [];
        /**
         * Indicates if we want to re-compute columns width. This should only happen:
         * 1) When headers change, with columns being added or removed
         * 2) When rows are lazily loaded for the first time
         */
        this.columnsSizesStable = false;
        this._subscriptions.push(organizer.computeWidths.subscribe(function () { return _this.computeHeadersWidth(); }));
    }
    /*
     * Are directives even allowed to do that?
     * It works because it's always attached on the same element as a component since they share the same selector,
     * but it feels like cheating.
     */
    DatagridMainRenderer.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._subscriptions.push(this.headers.changes.subscribe(function () {
            // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
            _this.columnsSizesStable = false;
            _this.stabilizeColumns();
        }));
        this._subscriptions.push(this.rows.changes.subscribe(function () {
            _this.stabilizeColumns();
        }));
    };
    DatagridMainRenderer.prototype.ngAfterViewInit = function () {
        this.stabilizeColumns();
    };
    DatagridMainRenderer.prototype.ngOnDestroy = function () {
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * Makes each header compute its width.
     */
    DatagridMainRenderer.prototype.computeHeadersWidth = function () {
        var _this = this;
        this.headers.forEach(function (header, index) {
            var width = header.computeWidth();
            _this.organizer.widths[index] = { px: width, strict: !!header.strictWidth };
        });
    };
    /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     */
    DatagridMainRenderer.prototype.stabilizeColumns = function () {
        if (this.columnsSizesStable) {
            return;
        }
        // No point resizing if there are no rows, we wait until they are actually loaded.
        if (this.rows.length > 0) {
            this.organizer.resize();
            this.columnsSizesStable = true;
        }
    };
    DatagridMainRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "clr-datagrid",
                    providers: [DomAdapter]
                } ] } ];
    /** @nocollapse */
    DatagridMainRenderer.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer, } ]; };
    DatagridMainRenderer.propDecorators = {
        'headers': [{ type: _angular_core.ContentChildren, args: [DatagridHeaderRenderer ] } ],
        'rows': [{ type: _angular_core.ContentChildren, args: [DatagridRowRenderer ] } ],
    };
    return DatagridMainRenderer;
}());

var DatagridTableRenderer = (function () {
    function DatagridTableRenderer(el, renderer, organizer) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.subscription = organizer.tableMode.subscribe(function (on) { return _this.tableMode(on); });
    }
    DatagridTableRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridTableRenderer.prototype.tableMode = function (on) {
        this.renderer.setElementClass(this.el.nativeElement, COMPUTE_WIDTH_CLASS, on);
    };
    DatagridTableRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDgTableWrapper]"
                } ] } ];
    /** @nocollapse */
    DatagridTableRenderer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, },
        { type: DatagridRenderOrganizer, } ]; };
    return DatagridTableRenderer;
}());

var DatagridHeadRenderer = (function () {
    function DatagridHeadRenderer(el, renderer, organizer) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.subscription = organizer.scrollbarWidth.subscribe(function (width) { return _this.accountForScrollbar(width); });
    }
    DatagridHeadRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridHeadRenderer.prototype.accountForScrollbar = function (width) {
        this.renderer.setElementStyle(this.el.nativeElement, "padding-right", width + "px");
    };
    DatagridHeadRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDgHead]"
                } ] } ];
    /** @nocollapse */
    DatagridHeadRenderer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, },
        { type: DatagridRenderOrganizer, } ]; };
    return DatagridHeadRenderer;
}());

var DatagridBodyRenderer = (function () {
    function DatagridBodyRenderer(el, organizer, domAdapter) {
        var _this = this;
        this.el = el;
        this.organizer = organizer;
        this.domAdapter = domAdapter;
        this.subscription = organizer.scrollbar.subscribe(function () { return _this.computeScrollbarWidth(); });
    }
    DatagridBodyRenderer.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    DatagridBodyRenderer.prototype.computeScrollbarWidth = function () {
        this.organizer.scrollbarWidth.next(this.domAdapter.scrollBarWidth(this.el.nativeElement));
    };
    DatagridBodyRenderer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDgBody]"
                } ] } ];
    /** @nocollapse */
    DatagridBodyRenderer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: DatagridRenderOrganizer, },
        { type: DomAdapter, } ]; };
    return DatagridBodyRenderer;
}());

var DATAGRID_DIRECTIVES = [
    // Core
    Datagrid,
    DatagridActionBar,
    DatagridActionOverflow,
    DatagridColumn,
    DatagridFilter,
    DatagridItems,
    DatagridRow,
    DatagridCell,
    DatagridFooter,
    DatagridPagination,
    DatagridPlaceholder,
    // Renderers
    DatagridMainRenderer,
    DatagridTableRenderer,
    DatagridHeadRenderer,
    DatagridHeaderRenderer,
    DatagridBodyRenderer,
    DatagridRowRenderer,
    DatagridCellRenderer,
    // Built-in shortcuts
    DatagridStringFilter
];

var menuPositions = [
    "bottom-left",
    "bottom-right",
    "top-left",
    "top-right",
    "left-bottom",
    "left-top",
    "right-bottom",
    "right-top"
];
var Dropdown = (function () {
    function Dropdown(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._open = false;
        this._openChanged = new _angular_core.EventEmitter(false);
        this.isMenuClosable = true;
    }
    Object.defineProperty(Dropdown.prototype, "menuPosition", {
        set: function (pos) {
            if (pos && (menuPositions.indexOf(pos) > -1)) {
                this._menuPosition = pos;
            }
            else {
                this._menuPosition = "bottom-left";
            }
            this.removeExistingDirectionClass();
            this.renderer.setElementClass(this.elementRef.nativeElement, this._menuPosition, true);
        },
        enumerable: true,
        configurable: true
    });
    Dropdown.prototype.removeExistingDirectionClass = function () {
        var currentClassList = this.elementRef.nativeElement.classList;
        menuPositions.forEach(function (direction) {
            if (currentClassList.contains(direction)) {
                currentClassList.toggle(direction);
            }
        });
    };
    Dropdown.prototype.toggleDropdown = function () {
        this.open = !this.open;
    };
    Object.defineProperty(Dropdown.prototype, "open", {
        get: function () {
            return this._open;
        },
        set: function (val) {
            this._open = val;
            this._openChanged.emit(val);
        },
        enumerable: true,
        configurable: true
    });
    //called on mouse clicks anywhere in the DOM.
    //Checks to see if the mouseclick happened on the host or outside
    Dropdown.prototype.onMouseClick = function (target) {
        if (this._open) {
            var current = target; //Get the element in the DOM on which the mouse was clicked
            var dropdownHost = this.elementRef.nativeElement; //Get the current dropdown native HTML element
            //Start checking if current and dropdownHost are equal. If not traverse to the parentNode and check again.
            while (current) {
                if (current === dropdownHost) {
                    return;
                }
                current = current.parentNode;
            }
            this._open = false; //Remove .open from the dropdown
        }
    };
    Dropdown.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-dropdown",
                    template: "\n        <ng-content select=\"[clrDropdownToggle]\"></ng-content>\n        <ng-content></ng-content>\n    ",
                    host: {
                        "[class.dropdown]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    Dropdown.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer, } ]; };
    Dropdown.propDecorators = {
        '_open': [{ type: _angular_core.HostBinding, args: ["class.open" ] }, { type: _angular_core.Input, args: ["clrDropdownMenuOpen" ] } ],
        '_openChanged': [{ type: _angular_core.Output, args: ["clrDropdownMenuOpenChange" ] } ],
        'isMenuClosable': [{ type: _angular_core.Input, args: ["clrCloseMenuOnItemClick" ] } ],
        'menuPosition': [{ type: _angular_core.Input, args: ["clrMenuPosition" ] } ],
        'onMouseClick': [{ type: _angular_core.HostListener, args: ["document:click", ["$event.target"] ] } ],
    };
    return Dropdown;
}());

var DropdownToggle = (function () {
    function DropdownToggle(_dropdown) {
        this._dropdown = _dropdown;
    }
    DropdownToggle.prototype.onDropdownToggleClick = function () {
        this._dropdown.toggleDropdown();
    };
    DropdownToggle.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDropdownToggle]",
                    host: {
                        "[class.dropdown-toggle]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    DropdownToggle.ctorParameters = function () { return [
        { type: Dropdown, } ]; };
    DropdownToggle.propDecorators = {
        'onDropdownToggleClick': [{ type: _angular_core.HostListener, args: ["click" ] } ],
    };
    return DropdownToggle;
}());

var DropdownItem = (function () {
    function DropdownItem(_dropdown, el) {
        this._dropdown = _dropdown;
        this.el = el;
    }
    DropdownItem.prototype.onDropdownItemClick = function () {
        if (this._dropdown.isMenuClosable && !this.el.nativeElement.classList.contains("disabled")) {
            this._dropdown.toggleDropdown();
        }
    };
    DropdownItem.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clrDropdownItem]",
                    host: {
                        "[class.dropdown-item]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    DropdownItem.ctorParameters = function () { return [
        { type: Dropdown, },
        { type: _angular_core.ElementRef, } ]; };
    DropdownItem.propDecorators = {
        'onDropdownItemClick': [{ type: _angular_core.HostListener, args: ["click" ] } ],
    };
    return DropdownItem;
}());

var DROPDOWN_DIRECTIVES = [
    Dropdown,
    DropdownToggle,
    DropdownItem
];

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var ClrResponsiveNavCodes = (function () {
    function ClrResponsiveNavCodes() {
    }
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_LEVEL_1", {
        get: function () { return 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_LEVEL_2", {
        get: function () { return 2; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLOSE_ALL", {
        get: function () { return "NAV_CLOSE_ALL"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_OPEN", {
        get: function () { return "NAV_OPEN"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLOSE", {
        get: function () { return "NAV_CLOSE"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_TOGGLE", {
        get: function () { return "NAV_TOGGLE"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_HAMBURGER_MENU", {
        get: function () { return "open-hamburger-menu"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_OVERFLOW_MENU", {
        get: function () { return "open-overflow-menu"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_TRIGGER_1", {
        get: function () { return "header-hamburger-trigger"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_TRIGGER_2", {
        get: function () { return "header-overflow-trigger"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_LEVEL_1", {
        get: function () { return "clr-nav-level-1"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavCodes, "NAV_CLASS_LEVEL_2", {
        get: function () { return "clr-nav-level-2"; },
        enumerable: true,
        configurable: true
    });
    return ClrResponsiveNavCodes;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var ClrResponsiveNavControlMessage = (function () {
    function ClrResponsiveNavControlMessage(_controlCode, _navLevel) {
        this._controlCode = _controlCode;
        this._navLevel = _navLevel;
    }
    Object.defineProperty(ClrResponsiveNavControlMessage.prototype, "controlCode", {
        get: function () {
            return this._controlCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavControlMessage.prototype, "navLevel", {
        get: function () {
            return this._navLevel;
        },
        enumerable: true,
        configurable: true
    });
    return ClrResponsiveNavControlMessage;
}());

var ClrResponsiveNavigationService = (function () {
    function ClrResponsiveNavigationService() {
        this.responsiveNavList = [];
        this.registerNavSubject = new rxjs_Subject.Subject();
        this.controlNavSubject = new rxjs_Subject.Subject();
        this.closeAllNavs(); //We start with all navs closed
    }
    Object.defineProperty(ClrResponsiveNavigationService.prototype, "registeredNavs", {
        get: function () {
            return this.registerNavSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrResponsiveNavigationService.prototype, "navControl", {
        get: function () {
            return this.controlNavSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ClrResponsiveNavigationService.prototype.registerNav = function (navLevel) {
        if (!navLevel || this.isNavRegistered(navLevel)) {
            return;
        }
        this.responsiveNavList.push(navLevel);
        this.registerNavSubject.next(this.responsiveNavList);
    };
    ClrResponsiveNavigationService.prototype.isNavRegistered = function (navLevel) {
        if (this.responsiveNavList.indexOf(navLevel) > -1) {
            console.error("Multiple clr-nav-level " + navLevel
                + " attributes found. Please make sure that only one exists");
            return true;
        }
        return false;
    };
    ClrResponsiveNavigationService.prototype.unregisterNav = function (navLevel) {
        var index = this.responsiveNavList.indexOf(navLevel);
        if (index > -1) {
            this.responsiveNavList.splice(index, 1);
            this.registerNavSubject.next(this.responsiveNavList);
        }
    };
    ClrResponsiveNavigationService.prototype.sendControlMessage = function (controlCode, navLevel) {
        var message = new ClrResponsiveNavControlMessage(controlCode, navLevel);
        this.controlNavSubject.next(message);
    };
    ClrResponsiveNavigationService.prototype.closeAllNavs = function () {
        var message = new ClrResponsiveNavControlMessage(ClrResponsiveNavCodes.NAV_CLOSE_ALL, -999);
        this.controlNavSubject.next(message);
    };
    ClrResponsiveNavigationService.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    ClrResponsiveNavigationService.ctorParameters = function () { return []; };
    return ClrResponsiveNavigationService;
}());

var MainContainer = (function () {
    function MainContainer(elRef, responsiveNavService) {
        this.elRef = elRef;
        this.responsiveNavService = responsiveNavService;
    }
    MainContainer.prototype.ngOnInit = function () {
        var _this = this;
        this._classList = this.elRef.nativeElement.classList;
        this._subscription = this.responsiveNavService.navControl.subscribe({
            next: function (message) {
                _this.processMessage(message);
            }
        });
    };
    MainContainer.prototype.processMessage = function (message) {
        var navClass = ClrResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
        if (message.controlCode === ClrResponsiveNavCodes.NAV_CLOSE_ALL) {
            this._classList.remove(ClrResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
            this._classList.remove(ClrResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
        }
        else if (message.navLevel === ClrResponsiveNavCodes.NAV_LEVEL_1) {
            this.controlNav(message.controlCode, navClass);
        }
        else if (message.navLevel === ClrResponsiveNavCodes.NAV_LEVEL_2) {
            navClass = ClrResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
            this.controlNav(message.controlCode, navClass);
        }
    };
    MainContainer.prototype.controlNav = function (controlCode, navClass) {
        if (controlCode === ClrResponsiveNavCodes.NAV_OPEN) {
            this._classList.add(navClass);
        }
        else if (controlCode === ClrResponsiveNavCodes.NAV_CLOSE) {
            this._classList.remove(navClass);
        }
        else if (controlCode === ClrResponsiveNavCodes.NAV_TOGGLE) {
            this._classList.toggle(navClass);
        }
    };
    MainContainer.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    MainContainer.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "clr-main-container",
                    host: {
                        "[class.main-container]": "true"
                    }
                } ] } ];
    /** @nocollapse */
    MainContainer.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: ClrResponsiveNavigationService, } ]; };
    return MainContainer;
}());

var LAYOUT_DIRECTIVES = [
    MainContainer
];

var ScrollingService = (function () {
    function ScrollingService(_document) {
        this._document = _document;
    }
    ScrollingService.prototype.stopScrolling = function () {
        this._document.body.classList.add("no-scrolling");
    };
    ScrollingService.prototype.resumeScrolling = function () {
        if (this._document.body.classList.contains("no-scrolling")) {
            this._document.body.classList.remove("no-scrolling");
        }
    };
    ScrollingService.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    ScrollingService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT ] } ] } ]; };
    return ScrollingService;
}());

var Modal = (function () {
    function Modal(_scrollingService) {
        this._scrollingService = _scrollingService;
        this._open = false;
        this._openChanged = new _angular_core.EventEmitter(false);
        this.closable = true;
        this.staticBackdrop = false;
    }
    Object.defineProperty(Modal.prototype, "sizeClass", {
        get: function () {
            if (this.size) {
                return "modal-" + this.size;
            }
            else {
                return "";
            }
        },
        enumerable: true,
        configurable: true
    });
    //Detect when _open is set to true and set no-scrolling to true
    Modal.prototype.ngOnChanges = function (changes) {
        if (changes && changes.hasOwnProperty("_open")) {
            if (changes["_open"].currentValue) {
                this._scrollingService.stopScrolling();
            }
            else {
                this._scrollingService.resumeScrolling();
            }
        }
    };
    Modal.prototype.ngOnDestroy = function () {
        this._scrollingService.resumeScrolling();
    };
    Modal.prototype.open = function () {
        if (this._open) {
            return;
        }
        this._open = true;
        this._openChanged.emit(true);
    };
    Modal.prototype.close = function () {
        if (!this.closable || this._open === false) {
            return;
        }
        this._open = false;
    };
    Modal.prototype.fadeDone = function (e) {
        if (e.toState === "void") {
            this._openChanged.emit(false);
        }
    };
    Modal.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-modal",
                    viewProviders: [ScrollingService],
                    template: "\n\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <div class=\"modal\" *ngIf=\"_open\">\n          <!--fixme: revisit when ngClass works with exit animation-->\n          <div [@fadeDown] (@fadeDown.done)=\"fadeDone($event)\"\n               class=\"modal-dialog\"\n               [class.modal-sm]=\"size == 'sm'\"\n               [class.modal-lg]=\"size == 'lg'\"\n               [class.modal-xl]=\"size == 'xl'\"\n               role=\"dialog\" aria-hidden=\"true\">\n              <div class=\"modal-content\">\n                  <div class=\"modal-header\">\n                      <button type=\"button\" class=\"close\" aria-label=\"Close\"\n                              *ngIf=\"closable\" (click)=\"close()\">\n                          <clr-icon aria-hidden=\"true\" shape=\"close\"></clr-icon>\n                      </button>\n                      <ng-content select=\".modal-title\"></ng-content>\n                  </div>\n                  <ng-content select=\".modal-body\"></ng-content>\n                  <ng-content select=\".modal-footer\"></ng-content>\n              </div>\n          </div>\n\n          <div [@fade] class=\"modal-backdrop\"\n               aria-hidden=\"true\"\n               (click)=\"staticBackdrop || close()\"></div>\n      </div>\n    ",
                    styles: ["\n        :host { display: inline-block; }\n    "],
                    animations: [
                        _angular_core.trigger("fadeDown", [
                            _angular_core.transition("void => *", [
                                _angular_core.style({
                                    opacity: 0,
                                    transform: "translate(0, -25%)"
                                }),
                                _angular_core.animate("0.2s ease-in-out")]),
                            _angular_core.transition("* => void", [
                                _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                                    opacity: 0,
                                    transform: "translate(0, -25%)"
                                }))])
                        ]),
                        _angular_core.trigger("fade", [
                            _angular_core.transition("void => *", [
                                _angular_core.style({
                                    opacity: 0
                                }),
                                _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                                    opacity: 0.85
                                }))
                            ]),
                            _angular_core.transition("* => void", [
                                _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                                    opacity: 0
                                }))
                            ])
                        ])
                    ]
                } ] } ];
    /** @nocollapse */
    Modal.ctorParameters = function () { return [
        { type: ScrollingService, } ]; };
    Modal.propDecorators = {
        '_open': [{ type: _angular_core.Input, args: ["clrModalOpen" ] } ],
        '_openChanged': [{ type: _angular_core.Output, args: ["clrModalOpenChange" ] } ],
        'closable': [{ type: _angular_core.Input, args: ["clrModalClosable" ] } ],
        'size': [{ type: _angular_core.Input, args: ["clrModalSize" ] } ],
        'staticBackdrop': [{ type: _angular_core.Input, args: ["clrModalStaticBackdrop" ] } ],
        'close': [{ type: _angular_core.HostListener, args: ["body:keyup.escape" ] } ],
    };
    return Modal;
}());

var MODAL_DIRECTIVES = [
    Modal
];

var Header = (function () {
    function Header(responsiveNavService) {
        this.responsiveNavService = responsiveNavService;
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
    }
    Header.prototype.ngOnInit = function () {
        var _this = this;
        this._subscription = this.responsiveNavService.registeredNavs.subscribe({
            next: function (navLevelList) {
                _this.initializeNavTriggers(navLevelList);
            }
        });
    };
    Object.defineProperty(Header.prototype, "responsiveNavCodes", {
        //getter to access the responsive navigation codes from the template
        get: function () {
            return ClrResponsiveNavCodes;
        },
        enumerable: true,
        configurable: true
    });
    //reset triggers. handles cases when an application has different nav levels on different pages.
    Header.prototype.resetNavTriggers = function () {
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
    };
    //decides which triggers to show on the header
    Header.prototype.initializeNavTriggers = function (navList) {
        var _this = this;
        this.resetNavTriggers();
        if (navList.length > 2) {
            console.error("More than 2 Nav Levels detected.");
            return;
        }
        navList.forEach(function (navLevel) {
            if (navLevel === ClrResponsiveNavCodes.NAV_LEVEL_1) {
                _this.isNavLevel1OnPage = true;
            }
            else if (navLevel === ClrResponsiveNavCodes.NAV_LEVEL_2) {
                _this.isNavLevel2OnPage = true;
            }
        });
    };
    //closes the nav that is open
    Header.prototype.closeOpenNav = function () {
        this.responsiveNavService.closeAllNavs();
    };
    //toggles the nav that is open
    Header.prototype.toggleNav = function (navLevel) {
        this.responsiveNavService.sendControlMessage(ClrResponsiveNavCodes.NAV_TOGGLE, navLevel);
    };
    Header.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    Header.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-header",
                    template: "\n        <button\n            *ngIf=\"isNavLevel1OnPage\"\n            class=\"header-hamburger-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_1)\">\n            <span></span>\n        </button>\n        <ng-content></ng-content>\n        <button\n            *ngIf=\"isNavLevel2OnPage\"\n            class=\"header-overflow-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_2)\">\n            <span></span>\n        </button>\n        <div class=\"header-backdrop\" (click)=\"closeOpenNav()\"></div>\n    ",
                    host: { "[class.header]": "true" }
                } ] } ];
    /** @nocollapse */
    Header.ctorParameters = function () { return [
        { type: ClrResponsiveNavigationService, } ]; };
    return Header;
}());

var NavLevelDirective = (function () {
    function NavLevelDirective(responsiveNavService, elementRef) {
        this.responsiveNavService = responsiveNavService;
        this.elementRef = elementRef;
    }
    NavLevelDirective.prototype.ngAfterContentInit = function () {
        if (this.level !== ClrResponsiveNavCodes.NAV_LEVEL_1 &&
            this.level !== ClrResponsiveNavCodes.NAV_LEVEL_2) {
            console.error("Nav Level can only be 1 or 2");
            return;
        }
        this.responsiveNavService.registerNav(this.level);
        this.addNavClass(this.level);
    };
    NavLevelDirective.prototype.addNavClass = function (level) {
        var navHostClassList = this.elementRef.nativeElement.classList;
        if (level === ClrResponsiveNavCodes.NAV_LEVEL_1) {
            navHostClassList.add(ClrResponsiveNavCodes.NAV_CLASS_LEVEL_1);
        }
        else if (level === ClrResponsiveNavCodes.NAV_LEVEL_2) {
            navHostClassList.add(ClrResponsiveNavCodes.NAV_CLASS_LEVEL_2);
        }
    };
    Object.defineProperty(NavLevelDirective.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavLevelDirective.prototype, "responsiveNavCodes", {
        //getter to access the responsive navigation codes from the template
        get: function () {
            return ClrResponsiveNavCodes;
        },
        enumerable: true,
        configurable: true
    });
    NavLevelDirective.prototype.open = function () {
        this.responsiveNavService.sendControlMessage(ClrResponsiveNavCodes.NAV_OPEN, this.level);
    };
    NavLevelDirective.prototype.close = function () {
        this.responsiveNavService.sendControlMessage(ClrResponsiveNavCodes.NAV_CLOSE, this.level);
    };
    //TODO: Figure out whats the best way to do this. Possible methods
    //1. HostListener (current solution)
    //2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason why
    NavLevelDirective.prototype.onMouseClick = function (target) {
        var this$1 = this;

        var current = target; //Get the element in the DOM on which the mouse was clicked
        var navHost = this.elementRef.nativeElement; //Get the current nav native HTML element
        //Start checking if current and navHost are equal.
        //If not traverse to the parentNode and check again.
        while (current) {
            if (current === navHost) {
                return;
            }
            else if (current.classList.contains("nav-link")) {
                this$1.close();
                return;
            }
            current = current.parentNode;
        }
    };
    NavLevelDirective.prototype.ngOnDestroy = function () {
        this.responsiveNavService.unregisterNav(this.level);
    };
    NavLevelDirective.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: "[clr-nav-level]"
                } ] } ];
    /** @nocollapse */
    NavLevelDirective.ctorParameters = function () { return [
        { type: ClrResponsiveNavigationService, },
        { type: _angular_core.ElementRef, } ]; };
    NavLevelDirective.propDecorators = {
        '_level': [{ type: _angular_core.Input, args: ["clr-nav-level" ] } ],
        'onMouseClick': [{ type: _angular_core.HostListener, args: ["click", ["$event.target"] ] } ],
    };
    return NavLevelDirective;
}());

var NAVIGATION_DIRECTIVES = [
    Header,
    NavLevelDirective
];

var StackView = (function () {
    function StackView() {
        /**
         * Undocumented experimental feature: inline editing.
         */
        this.editable = false;
        this.save = new _angular_core.EventEmitter(false);
        this._editMode = false;
        this.editingChange = new _angular_core.EventEmitter(false);
    }
    Object.defineProperty(StackView.prototype, "editing", {
        get: function () {
            return this.editable && this._editMode;
        },
        set: function (value) {
            if (this.editable) {
                this._editMode = value;
                this.editingChange.emit(value);
                if (!value) {
                    this.save.emit(null);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * End of undocumented experimental feature.
     */
    StackView.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-stack-view",
                    template: "\n        <ng-content select=\"clr-stack-header\"></ng-content>\n        <dl class=\"stack-view\"><ng-content></ng-content></dl>\n    ",
                    // Custom elements are inline by default.
                    styles: ["\n        :host { display: block; }\n    "]
                } ] } ];
    /** @nocollapse */
    StackView.ctorParameters = function () { return []; };
    StackView.propDecorators = {
        'save': [{ type: _angular_core.Output, args: ["clrStackSave" ] } ],
    };
    return StackView;
}());
var StackViewCustomTags = (function () {
    function StackViewCustomTags() {
    }
    // No behavior
    // The only purpose is to "declare" the tag in Angular2
    StackViewCustomTags.decorators = [
        { type: _angular_core.Directive, args: [{ selector: "clr-stack-label, clr-stack-content" } ] } ];
    /** @nocollapse */
    StackViewCustomTags.ctorParameters = function () { return []; };
    return StackViewCustomTags;
}());

var StackHeader = (function () {
    function StackHeader(stackView) {
        this.stackView = stackView;
    }
    StackHeader.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-stack-header",
                    template: "\n        <h4 class=\"stack-header\">\n            <span class=\"stack-title\"><ng-content></ng-content></span>\n            \n            <span class=\"stack-actions\">\n                <ng-content select=\".stack-action\"></ng-content>\n                <!-- Undocumented experimental feature: inline editing. -->\n                <button *ngIf=\"stackView.editable\" class=\"stack-action btn btn-sm btn-link\" \n                        (click)=\"stackView.editing = !stackView.editing\" type=\"button\">\n                        Edit\n                </button>\n                <!-- End of undocumented experimental feature. -->\n            </span>\n        </h4>\n    ",
                    // Custom elements are inline by default
                    styles: ["\n        :host { display: block; }\n    "]
                } ] } ];
    /** @nocollapse */
    StackHeader.ctorParameters = function () { return [
        { type: StackView, } ]; };
    return StackHeader;
}());

var StackBlock = (function () {
    /*
     * This would be more efficient with @ContentChildren, with the parent StackBlock
     * querying for children StackBlocks, but this feature is not available when downgrading
     * the component for Angular 1.
     */
    function StackBlock(parent) {
        this.parent = parent;
        this.expanded = false;
        this.expandedChange = new _angular_core.EventEmitter(false);
        this.expandable = false;
        this._changedChildren = 0;
        this._fullyInitialized = false;
        this._changed = false;
        if (parent) {
            parent.addChild();
        }
    }
    Object.defineProperty(StackBlock.prototype, "getChangedValue", {
        get: function () {
            return this._changed || (this._changedChildren > 0 && !this.expanded);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackBlock.prototype, "setChangedValue", {
        set: function (value) {
            this._changed = value;
            if (this.parent && this._fullyInitialized) {
                if (value) {
                    this.parent._changedChildren++;
                }
                else {
                    this.parent._changedChildren--;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    StackBlock.prototype.ngOnInit = function () {
        //in order to access the parent StackBlock's properties,
        //the child StackBlock  has to be fully initialized at first.
        this._fullyInitialized = true;
    };
    StackBlock.prototype.addChild = function () {
        this.expandable = true;
    };
    StackBlock.prototype.toggleExpand = function () {
        if (this.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    };
    StackBlock.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-stack-block",
                    template: "\n        <dt class=\"stack-block-label\" (click)=\"toggleExpand()\">\n            <ng-content select=\"clr-stack-label\"></ng-content>\n        </dt>\n        <dd class=\"stack-block-content\">\n            <ng-content></ng-content>\n        </dd>\n        <!-- FIXME: remove this string concatenation when boolean states are supported -->\n        <div [@collapse]=\"''+!expanded\" class=\"stack-children\">\n            <ng-content select=\"clr-stack-block\"></ng-content>\n        </div>\n    ",
                    // Custom elements are inline by default
                    styles: ["\n        :host { display: block; }\n    "],
                    // Make sure the host has the proper class for styling purposes
                    host: {
                        "[class.stack-block]": "true"
                    },
                    animations: [_angular_core.trigger("collapse", [
                            _angular_core.state("true", _angular_core.style({
                                "height": 0,
                                "overflow-y": "hidden"
                            })),
                            _angular_core.transition("true => false", [
                                _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                                    "height": "*",
                                    "overflow-y": "hidden"
                                }))
                            ]),
                            _angular_core.transition("false => true", [
                                _angular_core.style({
                                    "height": "*",
                                    "overflow-y": "hidden"
                                }),
                                _angular_core.animate("0.2s ease-in-out")
                            ])
                        ])]
                } ] } ];
    /** @nocollapse */
    StackBlock.ctorParameters = function () { return [
        { type: StackBlock, decorators: [{ type: _angular_core.SkipSelf }, { type: _angular_core.Optional } ] } ]; };
    StackBlock.propDecorators = {
        'expanded': [{ type: _angular_core.HostBinding, args: ["class.stack-block-expanded" ] }, { type: _angular_core.Input, args: ["clrSbExpanded" ] } ],
        'expandedChange': [{ type: _angular_core.Output, args: ["clrSbExpandedChange" ] } ],
        'expandable': [{ type: _angular_core.HostBinding, args: ["class.stack-block-expandable" ] }, { type: _angular_core.Input, args: ["clrSbExpandable" ] } ],
        'getChangedValue': [{ type: _angular_core.HostBinding, args: ["class.stack-block-changed" ] } ],
        'setChangedValue': [{ type: _angular_core.Input, args: ["clrSbNotifyChange" ] } ],
    };
    return StackBlock;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Undocumented experimental feature: inline editing.
 */
var StackControl = (function () {
    function StackControl(stackView) {
        var _this = this;
        this.stackView = stackView;
        this.modelChange = new _angular_core.EventEmitter(false);
        // Make the StackView editable, since it contains a StackControl
        this.stackView.editable = true;
        this.stackView.editingChange.subscribe(function (editing) {
            // Edit mode was closed
            if (!editing) {
                _this.modelChange.emit(_this.model);
            }
        });
    }
    return StackControl;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Undocumented experimental feature: inline editing.
 *
 * TODO: support more types of inputs: checkbox, radio, ...
 * TODO: Mirror input attributes from the host to the actual input: size, min, max, placeholder, ...
 */
var __extends$3 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var StackInput = (function (_super) {
    __extends$3(StackInput, _super);
    function StackInput(stackView) {
        _super.call(this, stackView);
        this.stackView = stackView;
        this.type = "text";
    }
    StackInput.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-stack-input",
                    inputs: ["model: clrModel", "type"],
                    outputs: ["modelChange: clrModelChange"],
                    template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <input [type]=\"type\" *ngIf=\"stackView.editing\" [(ngModel)]=\"model\"/>\n    "
                } ] } ];
    /** @nocollapse */
    StackInput.ctorParameters = function () { return [
        { type: StackView, } ]; };
    return StackInput;
}(StackControl));

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Undocumented experimental feature: inline editing.
 *
 * TODO: Offer a a way to customize the value displayed, plain value may be unreadable.
 */
var __extends$4 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var StackSelect = (function (_super) {
    __extends$4(StackSelect, _super);
    function StackSelect(stackView) {
        _super.call(this, stackView);
        this.stackView = stackView;
    }
    StackSelect.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-stack-select",
                    inputs: ["model: clrModel"],
                    outputs: ["modelChange: clrModelChange"],
                    template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <div class=\"select\" *ngIf=\"stackView.editing\" >\n            <select [(ngModel)]=\"model\">\n                <ng-content></ng-content>\n            </select>\n        </div>\n    "
                } ] } ];
    /** @nocollapse */
    StackSelect.ctorParameters = function () { return [
        { type: StackView, } ]; };
    return StackSelect;
}(StackControl));

var STACK_VIEW_DIRECTIVES = [
    StackView,
    StackHeader,
    StackBlock,
    StackViewCustomTags,
    /**
     * Undocumented experimental feature: inline editing.
     */
    StackInput,
    StackSelect
];

var TabContent = (function () {
    function TabContent() {
        this.active = false;
    }
    TabContent.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-tab-content",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <section>\n          <ng-content></ng-content>\n      </section>\n    ",
                    host: {
                        "[id]": "id",
                        "role": "tabpanel",
                        "[attr.aria-hidden]": "!active",
                        "[attr.aria-labelledby]": "ariaLabelledBy",
                        "[attr.data-hidden]": "!active",
                        "[class.active]": "active"
                    }
                } ] } ];
    /** @nocollapse */
    TabContent.ctorParameters = function () { return []; };
    TabContent.propDecorators = {
        'active': [{ type: _angular_core.Input, args: ["clrTabContentActive" ] } ],
        'id': [{ type: _angular_core.Input, args: ["clrTabContentId" ] } ],
    };
    return TabContent;
}());

var nbTabsComponents = 0;
var Tabs = (function () {
    function Tabs() {
        this._currentTabIndex = -1;
        this.currentTabIndexChanged = new _angular_core.EventEmitter(false);
        this.currentTabLinkChanged = new _angular_core.EventEmitter(false);
        this.currentTabContentChanged = new _angular_core.EventEmitter(false);
        this.id = "clr-tabs-" + (nbTabsComponents++);
    }
    Tabs.prototype.setUpLinksAndContents = function () {
        var _this = this;
        // first, iterate over tab links and contents and assign id's if it doesn't exist
        // also set the active tab index; future active tab index will override the earlier one if there are multiple
        this.tabLinks.forEach(function (tabLink, index) {
            if (!tabLink.id) {
                tabLink.id = _this.id + "-tab-" + index;
            }
            if (tabLink.active) {
                _this.currentTabLink = tabLink;
                _this.currentTabIndex = index;
            }
        });
        this.tabContents.forEach(function (tabContent, index) {
            if (!tabContent.id) {
                tabContent.id = _this.id + "-content-" + index;
            }
            if (tabContent.active) {
                _this.currentTabContent = tabContent;
            }
        });
        // second, iterate over tab links and contents to set the aria attributes
        this.tabLinks.forEach(function (tabLink, index) {
            if (index < _this.tabContents.length) {
                tabLink.ariaControls = _this.tabContents[index].id;
            }
        });
        this.tabContents.forEach(function (tabContent, index) {
            if (index < _this.tabLinks.length) {
                tabContent.ariaLabelledBy = _this.tabLinks[index].id;
            }
        });
        // third, set first one as active if there's no active tab link or tab content
        if (!this.currentTabLink && this.tabLinks.length > 0) {
            this.selectTab(this.tabLinks[0]);
        }
    };
    Tabs.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.setUpLinksAndContents();
        this.tabLinkChildren.changes.subscribe(function (children) {
            _this.setUpLinksAndContents();
        });
        this.tabContentChildren.changes.subscribe(function (children) {
            _this.setUpLinksAndContents();
        });
    };
    Tabs.prototype.overrideTabContentChildren = function (tabContentChildren) {
        this.tabContentChildren = tabContentChildren;
        this.setUpLinksAndContents();
    };
    Tabs.prototype.overrideTabLinkChildren = function (tabLinks) {
        this.tabLinkChildren = tabLinks;
        this.setUpLinksAndContents();
    };
    Object.defineProperty(Tabs.prototype, "tabLinks", {
        get: function () {
            return this.tabLinkChildren.toArray();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tabs.prototype, "tabContents", {
        get: function () {
            return this.tabContentChildren.toArray();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tabs.prototype, "currentTabContent", {
        get: function () {
            return this._currentTabContent;
        },
        set: function (tabContent) {
            this._currentTabContent = tabContent;
            this.currentTabContentChanged.emit(tabContent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tabs.prototype, "currentTabIndex", {
        get: function () {
            return this._currentTabIndex;
        },
        set: function (index) {
            this._currentTabIndex = index;
            this.currentTabIndexChanged.emit(index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tabs.prototype, "currentTabLink", {
        get: function () {
            return this._currentTabLink;
        },
        set: function (tabLink) {
            this._currentTabLink = tabLink;
            this.currentTabLinkChanged.emit(tabLink);
        },
        enumerable: true,
        configurable: true
    });
    Tabs.prototype.selectTab = function (tabLink) {
        // deactivate all tabs and contents
        this.tabLinks.forEach(function (tab) { return tab.active = false; });
        this.tabContents.forEach(function (tabContent) { return tabContent.active = false; });
        // activate the selected Tab
        var index = this.tabLinks.indexOf(tabLink);
        tabLink.active = true;
        this.currentTabLink = tabLink;
        this.currentTabIndex = index;
        // activate the matching content if it exists; if we have a tabLink with no associated content, it'll show blank
        var selectedTabContent = null;
        if (index < this.tabContents.length) {
            selectedTabContent = this.tabContents[index];
            this.currentTabContent = selectedTabContent;
            selectedTabContent.active = true;
        }
    };
    Tabs.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-tabs",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <ul class=\"nav\" role=\"tablist\">\n          <ng-content select=\"clr-tab-link\"></ng-content>\n      </ul>\n      <ng-content select=\"clr-tab-content\"></ng-content>\n    "
                } ] } ];
    /** @nocollapse */
    Tabs.ctorParameters = function () { return []; };
    Tabs.propDecorators = {
        'tabLinkChildren': [{ type: _angular_core.ContentChildren, args: [_angular_core.forwardRef(function () { return TabLink; }) ] } ],
        'tabContentChildren': [{ type: _angular_core.ContentChildren, args: [_angular_core.forwardRef(function () { return TabContent; }) ] } ],
        '_currentTabIndex': [{ type: _angular_core.Input, args: ["clrTabsCurrentTabIndex" ] } ],
        '_currentTabLink': [{ type: _angular_core.Input, args: ["clrTabsCurrentTabLink" ] } ],
        '_currentTabContent': [{ type: _angular_core.Input, args: ["clrTabsCurrentTabContent" ] } ],
        'currentTabIndexChanged': [{ type: _angular_core.Output, args: ["clrTabsCurrentTabIndexChanged" ] } ],
        'currentTabLinkChanged': [{ type: _angular_core.Output, args: ["clrTabsCurrentTabLinkChanged" ] } ],
        'currentTabContentChanged': [{ type: _angular_core.Output, args: ["clrTabsCurrentTabContentChanged" ] } ],
    };
    return Tabs;
}());

var TabLink = (function () {
    function TabLink(tabs) {
        this.tabs = tabs;
        this.active = false;
    }
    TabLink.prototype.onClick = function () {
        this.tabs.selectTab(this);
        return false; // so that browser doesn't navigate to the href of the anchor tag
    };
    TabLink.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-tab-link",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <button class=\"btn btn-link nav-link\" (click)=\"onClick()\" type=\"button\">\n          <ng-content></ng-content>\n      </button>\n    ",
                    host: {
                        "[id]": "id",
                        "[attr.aria-selected]": "active",
                        "[attr.aria-controls]": "ariaControls",
                        "role": "presentation",
                        "[class.nav-item]": "true",
                        "[class.active]": "active"
                    }
                } ] } ];
    /** @nocollapse */
    TabLink.ctorParameters = function () { return [
        { type: Tabs, } ]; };
    TabLink.propDecorators = {
        'active': [{ type: _angular_core.Input, args: ["clrTabLinkActive" ] } ],
        'id': [{ type: _angular_core.Input, args: ["clrTabLinkId" ] } ],
    };
    return TabLink;
}());

var TABS_DIRECTIVES = [
    TabContent,
    TabLink,
    Tabs
];

var TreeSelectionService = (function () {
    function TreeSelectionService() {
        this.selectable = false;
        //Boolean not necessary. Just emitting any value will indicate that a change has occurred
        this._change = new rxjs_Subject.Subject();
    }
    Object.defineProperty(TreeSelectionService.prototype, "change", {
        get: function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    
    TreeSelectionService.prototype.notify = function () {
        this._change.next(true);
    };
    TreeSelectionService.prototype.verifyTreeSelection = function (selection) {
        var _this = this;
        if (!selection.hasOwnProperty("selected")) {
            throw "clrTreeSelection should have the selected property";
        }
        //Check if the "children" property exists and is of type array
        if (selection.hasOwnProperty("children")) {
            if (Object.prototype.toString.call(selection.children) !== "[object Array]") {
                throw "clrTreeSelection should be of type array. Received type " +
                    typeof selection.children;
            }
            selection.children.forEach(function (child) { return _this.verifyTreeSelection(child); });
        }
    };
    TreeSelectionService.decorators = [
        { type: _angular_core.Injectable } ];
    /** @nocollapse */
    TreeSelectionService.ctorParameters = function () { return []; };
    return TreeSelectionService;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var AbstractTreeSelection = (function () {
    function AbstractTreeSelection(parent, treeSelectionService) {
        this.parent = parent;
        this.treeSelectionService = treeSelectionService;
        this._selected = false;
        this._indeterminate = false;
    }
    Object.defineProperty(AbstractTreeSelection.prototype, "children", {
        get: function () { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTreeSelection.prototype, "selected", {
        get: function () {
            return this._selected;
        },
        set: function (value) {
            this._selected = value;
            this._indeterminate = false;
            this.children.forEach(function (child) { return child.parentChanged(value); });
            if (this.parent) {
                this.parent.childChanged();
            }
            this.treeSelectionService.notify();
            this.selectedChanged();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTreeSelection.prototype, "indeterminate", {
        get: function () {
            return this._indeterminate;
        },
        enumerable: true,
        configurable: true
    });
    AbstractTreeSelection.prototype.childChanged = function () {
        var this$1 = this;

        var oneSelectedChild = false;
        var previousSelectedValue = this._selected;
        var previousIndeterminateValue = this._indeterminate;
        this._selected = true;
        this._indeterminate = false;
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child.indeterminate) {
                this$1._selected = false;
                this$1._indeterminate = true;
                break;
            }
            if (child.selected) {
                oneSelectedChild = true;
                if (this$1._selected === false) {
                    this$1._indeterminate = true;
                    break;
                }
            }
            else {
                this$1._selected = false;
                if (oneSelectedChild) {
                    this$1._indeterminate = true;
                    break;
                }
            }
        }
        if (this.parent
            && (this._selected !== previousSelectedValue
                || this._indeterminate !== previousIndeterminateValue)) {
            this.parent.childChanged();
        }
        if (this.selected !== previousSelectedValue) {
            this.selectedChanged();
        }
    };
    AbstractTreeSelection.prototype.parentChanged = function (selected) {
        if (selected && !this.selected) {
            this._selected = true;
            this._indeterminate = false;
            this.children.forEach(function (child) { return child.parentChanged(true); });
            this.selectedChanged();
        }
        if (!selected && (this.selected || this.indeterminate)) {
            this._selected = false;
            this._indeterminate = false;
            this.children.forEach(function (child) { return child.parentChanged(false); });
            this.selectedChanged();
        }
    };
    AbstractTreeSelection.prototype.toTreeSelection = function () {
        if (this.selected || this.indeterminate) {
            return {
                model: this.model,
                selected: this.selected,
                children: this.children.map(function (child) { return child.toTreeSelection(); })
                    .filter(function (child) { return !!child; })
            };
        }
        return null;
    };
    AbstractTreeSelection.prototype.matchTreeSelection = function (selectionArray) {
        var _loop_1 = function(selection) {
            if (this_1.model === selection.model) {
                if (this_1.selected !== selection.selected) {
                    this_1.selected = selection.selected;
                }
                if (selection.children) {
                    this_1.children.forEach(function (child) { return child.matchTreeSelection(selection.children); });
                }
                return "break";
            }
        };
        var this_1 = this;
        for (var _i = 0, selectionArray_1 = selectionArray; _i < selectionArray_1.length; _i++) {
            var selection = selectionArray_1[_i];
            var state_1 = _loop_1(selection);
            if (state_1 === "break") { break; }
        }
    };
    return AbstractTreeSelection;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var __extends$5 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TreeNode = (function (_super) {
    __extends$5(TreeNode, _super);
    function TreeNode(parent, treeSelectionService) {
        _super.call(this, parent, treeSelectionService);
        this.treeSelectionService = treeSelectionService;
        this.nodeSelectedChange = new _angular_core.EventEmitter(true);
        this.expanded = false;
        this.expandedChange = new _angular_core.EventEmitter(true);
        this.isExpandable = false;
        this.loading = false;
        /*Note: Experimental Feature. Might be removed*/
        this.isCompact = false;
    }
    Object.defineProperty(TreeNode.prototype, "children", {
        /**
         * Generates the child TreeNodes array from the ContentChildren QueryList
         * @returns {TreeNode[]|Array}
         */
        get: function () {
            var _this = this;
            return this._children ? this._children.toArray().filter(function (child) { return _this !== child; }) : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "nodeSelected", {
        get: function () {
            return this.selected;
        },
        set: function (value) {
            if (this.selected !== value) {
                this.selected = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    TreeNode.prototype.selectedChanged = function () {
        this.nodeSelectedChange.emit(this.selected);
    };
    Object.defineProperty(TreeNode.prototype, "hasChildren", {
        /**
         * Returns true if a TreeNode contains child TreeNodes and false otherwise.
         * @returns {boolean}
         */
        get: function () {
            if (this.children && this.children.length > 0) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "caretDirection", {
        /**
         * Determines the caret direction based on the expanded/collapsed
         * state of the TreeNode.
         *
         * Returns "down" when collapsed and "right" when expanded
         * @returns {string|string}
         */
        get: function () {
            return (this.expanded) ? "down" : "right";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clicking on the caret sign calls this method.
     * Toggles the expanded/collapsed state of the TreeNode
     */
    TreeNode.prototype.toggleExpand = function () {
        this.expanded = !this.expanded;
        this.expandedChange.emit(this.expanded);
    };
    Object.defineProperty(TreeNode.prototype, "selectable", {
        /**
         * Returns if the TreeNode is selectable or not
         * @returns {boolean}
         */
        get: function () {
            if (this.treeSelectionService) {
                return this.treeSelectionService.selectable;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    TreeNode.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-tree-node",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n      <button\n          class=\"clr-treenode-caret\"\n          (click)=\"toggleExpand()\"\n          *ngIf=\"(isExpandable || hasChildren) && (!loading)\">\n          <clr-icon\n              shape=\"caret\"\n              [attr.dir]=\"caretDirection\"></clr-icon>\n      </button>\n      <span class=\"clr-treenode-spinner spinner\" *ngIf=\"isExpandable && loading\">\n          Loading...\n      </span>\n      <clr-checkbox\n          *ngIf=\"selectable\"\n          [(ngModel)]=\"selected\"\n          [clrIndeterminate]=\"indeterminate\"></clr-checkbox>\n      <div class=\"clr-treenode-content\">\n          <ng-content></ng-content>\n      </div>\n      <!-- FIXME: remove this string concatenation when boolean states are supported -->\n      <div\n          class=\"clr-treenode-children\"\n          [@collapse]=\"''+!expanded\">\n          <ng-content select=\"clr-tree-node\"></ng-content>\n      </div>\n    ",
                    animations: [_angular_core.trigger("collapse", [
                            _angular_core.state("true", _angular_core.style({
                                "height": 0,
                                "overflow-y": "hidden"
                            })),
                            _angular_core.transition("true => false", [
                                _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                                    "height": "*",
                                    "overflow-y": "hidden"
                                }))
                            ]),
                            _angular_core.transition("false => true", [
                                _angular_core.style({
                                    "height": "*",
                                    "overflow-y": "hidden"
                                }),
                                _angular_core.animate("0.2s ease-in-out")
                            ])
                        ])],
                    host: { "[class.clr-tree--compact]": "isCompact" }
                } ] } ];
    /** @nocollapse */
    TreeNode.ctorParameters = function () { return [
        { type: TreeNode, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf } ] },
        { type: TreeSelectionService, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf } ] } ]; };
    TreeNode.propDecorators = {
        'model': [{ type: _angular_core.Input, args: ["clrTreeModel" ] } ],
        '_children': [{ type: _angular_core.ContentChildren, args: [TreeNode ] } ],
        'nodeSelected': [{ type: _angular_core.Input, args: ["clrTreeNodeSelected" ] } ],
        'nodeSelectedChange': [{ type: _angular_core.Output, args: ["clrTreeNodeSelectedChange" ] } ],
        'expanded': [{ type: _angular_core.Input, args: ["clrTreeNodeExpanded" ] } ],
        'expandedChange': [{ type: _angular_core.Output, args: ["clrTreeNodeExpandedChange" ] } ],
        'isExpandable': [{ type: _angular_core.Input, args: ["clrTreeNodeExpandable" ] } ],
        'loading': [{ type: _angular_core.Input, args: ["clrTreeNodeLoading" ] } ],
        'isCompact': [{ type: _angular_core.Input, args: ["clrTreeCompact" ] } ],
    };
    return TreeNode;
}(AbstractTreeSelection));

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var TreeView = (function () {
    function TreeView(treeSelectionService) {
        this.treeSelectionService = treeSelectionService;
        /*Note: Experimental Feature. Might be removed*/
        this.isCompact = false;
        this.selectedChange = new _angular_core.EventEmitter(true);
    }
    TreeView.prototype.generateTreeSelection = function () {
        var treeSelection = [];
        this.children.forEach(function (child) { return treeSelection.push(child.toTreeSelection()); });
        return treeSelection.filter(function (selection) { return !!selection; });
    };
    /**
     * Verifies whether the input received is valid or not.
     * Throws an error if invalid.
     * @param selectionArray
     */
    TreeView.prototype.verifyInput = function (selectionArray) {
        var _this = this;
        //Check if selection is of type array
        //http://stackoverflow.com/a/4775737/3538394
        if (Object.prototype.toString.call(selectionArray) !== "[object Array]") {
            throw "clrTreeSelection should be of type array. Received " + typeof selectionArray;
        }
        selectionArray.forEach(function (selection) { return _this.treeSelectionService.verifyTreeSelection(selection); });
    };
    TreeView.prototype.populateTree = function (selectionArray) {
        if (this.children && selectionArray && selectionArray.length > 0) {
            this.children.toArray().forEach(function (child) { return child.matchTreeSelection(selectionArray); });
        }
    };
    Object.defineProperty(TreeView.prototype, "selected", {
        set: function (value) {
            this.verifyInput(value);
            this.treeSelectionService.selectable = true;
            this.initialInput = value;
        },
        enumerable: true,
        configurable: true
    });
    TreeView.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.treeSelectionService.change.subscribe(function () {
            if (_this.children) {
                _this.selectedChange.emit(_this.generateTreeSelection());
            }
        });
        this.populateTree(this.initialInput);
    };
    TreeView.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-tree",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <ng-content></ng-content>\n      <ng-content select=\"clr-tree-node\"></ng-content>\n    ",
                    host: { "[class.clr-tree--compact]": "isCompact" },
                    providers: [TreeSelectionService]
                } ] } ];
    /** @nocollapse */
    TreeView.ctorParameters = function () { return [
        { type: TreeSelectionService, } ]; };
    TreeView.propDecorators = {
        'children': [{ type: _angular_core.ContentChildren, args: [TreeNode ] } ],
        'isCompact': [{ type: _angular_core.Input, args: ["clrTreeCompact" ] } ],
        'selected': [{ type: _angular_core.Input, args: ["clrTreeSelected" ] } ],
        'selectedChange': [{ type: _angular_core.Output, args: ["clrTreeSelectedChange" ] } ],
    };
    return TreeView;
}());

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

var TREE_VIEW_DIRECTIVES = [
    TreeNode,
    TreeView
];

var __extends$7 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var WizardStep = (function (_super) {
    __extends$7(WizardStep, _super);
    function WizardStep(wizard, elementRef) {
        _super.call(this, wizard);
        this.wizard = wizard;
        this.elementRef = elementRef;
        // is the section completed
        this.isCompleted = false;
        // input variable, optional, to set if this tab is skipped
        this.isSkipped = false;
    }
    WizardStep.prototype.onClick = function () {
        // IE 10 fix to prevent click of disabled tab
        if (!this.active && this.isCompleted) {
            _super.prototype.onClick.call(this);
        }
        return false;
    };
    WizardStep.prototype.ngOnInit = function () {
        // The nav text will be the title of the main section.
        this.title = this.elementRef.nativeElement.innerText.trim();
    };
    WizardStep.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-wizard-step",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <button class=\"btn btn-link nav-link\" (click)=\"onClick()\" type=\"button\">\n          <ng-content></ng-content>\n      </button>\n    ",
                    host: {
                        "[id]": "id",
                        "[attr.aria-selected]": "active",
                        "[attr.aria-controls]": "ariaControls",
                        "role": "presentation",
                        "[class.clr-nav-link]": "true",
                        "[class.active]": "active",
                        "[class.disabled]": "!active && !isCompleted",
                        "[class.complete]": "isCompleted",
                        "[class.skipped]": "isSkipped"
                    }
                } ] } ];
    /** @nocollapse */
    WizardStep.ctorParameters = function () { return [
        { type: Wizard, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return Wizard; }) ] } ] },
        { type: _angular_core.ElementRef, } ]; };
    WizardStep.propDecorators = {
        'isSkipped': [{ type: _angular_core.Input, args: ["clrWizardStepIsSkipped" ] } ],
        'id': [{ type: _angular_core.Input, args: ["clrWizardStepId" ] } ],
    };
    return WizardStep;
}(TabLink));

var __extends$8 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var WizardPage = (function (_super) {
    __extends$8(WizardPage, _super);
    function WizardPage() {
        _super.call(this);
        this.hasProjectedTitleContent = false;
        // User can bind his event handler for onCommit of the main content
        this.onCommit = new _angular_core.EventEmitter(false);
        // User can bind his/her event handler for onLoad of the main content
        this.onLoad = new _angular_core.EventEmitter(false);
        // input variable, optional, to set if this tab is skipped
        this.isSkipped = false;
        // input variable, optional, to set if this tab is skipped
        this.preventDefault = false;
        // Emitter for Next button state changes
        this.nextDisabledChanged = new _angular_core.EventEmitter(false);
    }
    WizardPage.prototype.ngOnInit = function () {
        var projectedTitleHTML = this.titleContainer.nativeElement.innerHTML.trim();
        this.hasProjectedTitleContent = projectedTitleHTML.length > 0;
    };
    WizardPage.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-wizard-page",
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <section>\n          <label #titleContainer class=\"text-light\">\n              {{title}}\n              <ng-content select=\".wizard-page-title\"></ng-content>\n          </label>\n\n          <div class=\"content-wrapper\">\n              <ng-content></ng-content>\n          </div>\n      </section>\n    ",
                    host: {
                        "[id]": "id",
                        "[class.clr-nav-content]": "true",
                        "role": "tabpanel",
                        "[attr.aria-hidden]": "!active",
                        "[attr.aria-labelledby]": "ariaLabelledBy",
                        "[attr.data-hidden]": "!active",
                        "[class.active]": "active"
                    }
                } ] } ];
    /** @nocollapse */
    WizardPage.ctorParameters = function () { return []; };
    WizardPage.propDecorators = {
        'titleContainer': [{ type: _angular_core.ViewChild, args: ["titleContainer" ] } ],
        'onCommit': [{ type: _angular_core.Output, args: ["clrWizardPageOnCommit" ] } ],
        'onLoad': [{ type: _angular_core.Output, args: ["clrWizardPageOnLoad" ] } ],
        'isSkipped': [{ type: _angular_core.Input, args: ["clrWizardPageIsSkipped" ] } ],
        'preventDefault': [{ type: _angular_core.Input, args: ["clrWizardPagePreventDefault" ] } ],
        'nextDisabled': [{ type: _angular_core.Input, args: ["clrWizardPageNextDisabled" ] } ],
        'errorFlag': [{ type: _angular_core.Input, args: ["clrWizardPageErrorFlag" ] } ],
        'nextDisabledChanged': [{ type: _angular_core.Output, args: ["clrWizardPageNextDisabledChanged" ] } ],
    };
    return WizardPage;
}(TabContent));

var __extends$6 = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nbWizardComponents = 0;
var Wizard = (function (_super) {
    __extends$6(Wizard, _super);
    function Wizard(_scrollingService) {
        _super.call(this);
        this._scrollingService = _scrollingService;
        this.size = "xl"; // xl is the default size
        // Variable that toggles open/close of the wizard component.
        this._open = false;
        // Variable that toggles open/close of the wizard component.
        this.closable = true;
        // EventEmitter which is emitted on open/close of the wizard.
        this._openChanged = new _angular_core.EventEmitter(false);
        // User can bind his event handler for onCancel of the main content
        this.onCancel = new _angular_core.EventEmitter(false);
        // Flag to toggle between Next and Finish button
        this.isLast = false;
        // Flag to hide/show back button
        this.isFirst = true;
        // The current page
        this.currentPage = null;
        this.id = "clr-wizard-" + (nbWizardComponents++);
    }
    //Detect when _open is set to true and set no-scrolling to true
    Wizard.prototype.ngOnChanges = function (changes) {
        if (changes && changes.hasOwnProperty("_open")) {
            if (changes["_open"].currentValue) {
                this._scrollingService.stopScrolling();
            }
            else {
                this._scrollingService.resumeScrolling();
            }
        }
    };
    Wizard.prototype.ngAfterContentInit = function () {
        var _this = this;
        // set the tab content's title to match the tab link's title
        this.wizardPageChildren.forEach(function (wizardPage, index) {
            var children = _this.wizardStepChildren.toArray();
            if (children[index] && !wizardPage.hasProjectedTitleContent) {
                wizardPage.title = children[index].title;
            }
        });
        // override superclass' children to setup the proper linked relationship between
        // tabs and contents
        _super.prototype.overrideTabLinkChildren.call(this, this.wizardStepChildren);
        _super.prototype.overrideTabContentChildren.call(this, this.wizardPageChildren);
        // set first step of the wizard as active/current one
        if (this.tabLinks.length > 0) {
            this.selectTab(this.tabLinks[0]);
        }
    };
    Object.defineProperty(Wizard.prototype, "tabLinks", {
        // returns only tabLinks that are not skipped
        get: function () {
            return this.wizardStepChildren.filter(function (wizardStep) {
                return !wizardStep.isSkipped;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "tabContents", {
        // returns only tabContents that are not skipped
        get: function () {
            return this.wizardPageChildren.filter(function (wizardPage) {
                return !wizardPage.isSkipped;
            });
        },
        enumerable: true,
        configurable: true
    });
    // open --
    //
    // This is a public function that can be used to programmatically open the
    // wizard.
    Wizard.prototype.open = function () {
        this._open = true;
        this._openChanged.emit(true);
    };
    // close --
    //
    // This is a public function that can be used to programmatically close the
    // wizard.
    Wizard.prototype.close = function () {
        this._open = false;
        this.onCancel.emit(null);
        this._openChanged.emit(false);
    };
    // _close --
    //
    // This is a private function that is called on the click of the close / cancel
    // button and emits the onCancel event of the active tab.
    Wizard.prototype._close = function (event) {
        this.close();
    };
    // _next --
    //
    // This is a private function that is called on the click of the next
    // button and emits the onCommit event of the active tab.
    Wizard.prototype._next = function (event) {
        var totalSteps = this.tabLinks.length - 1;
        var i = this.currentTabIndex;
        var page = this.tabContents[i];
        if (!page.nextDisabled) {
            page.onCommit.emit(null);
            if (!page.preventDefault) {
                // If no handler for finish button, then close wizard on click
                // of finish by default
                if (totalSteps === i) {
                    this.close();
                }
                else {
                    this.next();
                }
            }
        }
    };
    // next --
    //
    // When called, after successful validation, the wizard will move to the
    // next page.
    // This is a public function that can be used to programmatically advance
    // the user to the next page.
    Wizard.prototype.next = function () {
        var i = this.currentTabIndex;
        var totalSteps = this.tabLinks.length - 1;
        var page = this.tabContents[i];
        // Call the onCommit or the Validation function of that step, and if it
        // returns true, continue to the next step.
        if (i < totalSteps && !page.nextDisabled) {
            var wizardStep = this.tabLinks[i];
            var nextStep = this.tabLinks[i + 1];
            wizardStep.isCompleted = true;
            this.selectTab(nextStep);
        }
    };
    // prev --
    //
    // When called, the wizard will move to the prev page.
    // This is a public function that can be used to programmatically go back
    // to the previous step.
    Wizard.prototype.prev = function () {
        var i = this.currentTabIndex;
        if (i > 0) {
            var wizardStep = this.tabLinks[i];
            var prevStep = this.tabLinks[i - 1];
            wizardStep.isCompleted = false;
            prevStep.isCompleted = false;
            this.selectTab(prevStep);
        }
    };
    // selectTab --
    //
    // Base class function overridden to call the onLoad event emitter
    Wizard.prototype.selectTab = function (wizardNav) {
        _super.prototype.selectTab.call(this, wizardNav);
        var page = this.currentTabContent;
        this.currentPage = page;
        page.onLoad.emit(false);
        // Toggles next and finish button
        var totalSteps = this.tabLinks.length - 1;
        this.isLast = this.currentTabIndex === totalSteps;
        this.isFirst = this.currentTabIndex === 0;
    };
    // skipTab --
    //
    // Public function to skip a Tab given its uniqueId
    Wizard.prototype.skipTab = function (tabId) {
        this._setTabIsSkipped(tabId, true);
    };
    // unSkipTab --
    //
    // Public function to unSkip a tab given its uniqueId
    Wizard.prototype.unSkipTab = function (tabId) {
        this._setTabIsSkipped(tabId, false);
    };
    Wizard.prototype._setTabIsSkipped = function (tabId, isSkipped) {
        var _this = this;
        this.wizardStepChildren.forEach(function (wizardStep, index) {
            if (wizardStep.id === tabId) {
                wizardStep.isSkipped = isSkipped;
                // set the isSkipped property of the matching content if it exists
                if (index < _this.wizardPageChildren.length) {
                    var children = _this.wizardPageChildren.toArray();
                    children[index].isSkipped = isSkipped;
                }
            }
        });
    };
    Wizard.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: "clr-wizard",
                    viewProviders: [ScrollingService],
                    template: "\n      <!--\n        ~ Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n        ~ This software is released under MIT license.\n        ~ The full license information can be found in LICENSE in the root directory of this project.\n        -->\n\n      <clr-modal\n            [clrModalOpen]=\"_open\"\n            [clrModalSize]=\"size\"\n            [clrModalClosable]=\"closable\"\n            [clrModalStaticBackdrop]=\"true\"\n            (clrModalOpenChange)=\"close()\">\n\n         <div class=\"modal-body\">\n            <div class=\"content-container\">\n               <main class=\"content-area\">\n                  <ng-content></ng-content>\n               </main>\n\n               <nav class=\"nav-panel sidenav\">\n                  <div class=\"text-light\">\n                     <ng-content select=\".wizard-title\"></ng-content>\n                  </div>\n\n                  <ol class=\"nav navList\" role=\"tablist\">\n                     <ng-content select=\"clr-wizard-step\"></ng-content>\n                  </ol>\n               </nav>\n            </div>\n         </div>\n\n         <div class=\"modal-footer\">\n            <button class=\"btn btn-link\" (click)=\"_close($event)\">Cancel</button>\n            <button class=\"btn btn-outline\"\n                  *ngIf=\"!isFirst\" (click)=\"prev($event)\">Back</button>\n            <button class=\"btn btn-primary\"\n                  [class.disabled]=\"currentPage?.nextDisabled\"\n                  (click)=\"_next($event)\">{{isLast? 'Finish' : 'Next'}}</button>\n         </div>\n\n      </clr-modal>\n    ",
                    host: {
                        "[class.clr-wizard]": "true",
                        "[class.main-container]": "true",
                        "[class.wizard-md]": "size == 'md'",
                        "[class.wizard-lg]": "size == 'lg'",
                        "[class.wizard-lx]": "size == 'lx'"
                    }
                } ] } ];
    /** @nocollapse */
    Wizard.ctorParameters = function () { return [
        { type: ScrollingService, } ]; };
    Wizard.propDecorators = {
        'wizardStepChildren': [{ type: _angular_core.ContentChildren, args: [WizardStep ] } ],
        'wizardPageChildren': [{ type: _angular_core.ContentChildren, args: [WizardPage ] } ],
        'size': [{ type: _angular_core.Input, args: ["clrWizardSize" ] } ],
        '_open': [{ type: _angular_core.Input, args: ["clrWizardOpen" ] } ],
        'closable': [{ type: _angular_core.Input, args: ["clrWizardClosable" ] } ],
        '_openChanged': [{ type: _angular_core.Output, args: ["clrWizardOpenChanged" ] } ],
        'onCancel': [{ type: _angular_core.Output, args: ["clrWizardOnCancel" ] } ],
        '_close': [{ type: _angular_core.HostListener, args: ["body:keyup.escape" ] } ],
    };
    return Wizard;
}(Tabs));

var WIZARD_DIRECTIVES = [
    Wizard,
    WizardStep,
    WizardPage
];

var IconCustomTag = (function () {
    function IconCustomTag() {
    }
    // No behavior
    // The only purpose is to "declare" the tag in Angular2
    IconCustomTag.decorators = [
        { type: _angular_core.Directive, args: [{ selector: "clr-icon" } ] } ];
    /** @nocollapse */
    IconCustomTag.ctorParameters = function () { return []; };
    return IconCustomTag;
}());

var ICON_DIRECTIVES = [
    IconCustomTag
];

var ClarityModule = (function () {
    function ClarityModule() {
    }
    ClarityModule.forRoot = function () {
        return {
            ngModule: ClarityModule,
            providers: [ClrResponsiveNavigationService]
        };
    };
    ClarityModule.forChild = function () {
        return {
            ngModule: ClarityModule,
            providers: []
        };
    };
    ClarityModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [
                        _angular_common.CommonModule,
                        _angular_forms.FormsModule
                    ],
                    declarations: [
                        ALERT_DIRECTIVES,
                        CHECKBOX_DIRECTIVES,
                        CODE_HIGHLIGHT_DIRECTIVES,
                        DATAGRID_DIRECTIVES,
                        DROPDOWN_DIRECTIVES,
                        LAYOUT_DIRECTIVES,
                        MODAL_DIRECTIVES,
                        NAVIGATION_DIRECTIVES,
                        STACK_VIEW_DIRECTIVES,
                        TABS_DIRECTIVES,
                        TREE_VIEW_DIRECTIVES,
                        WIZARD_DIRECTIVES,
                        ICON_DIRECTIVES
                    ],
                    exports: [
                        ALERT_DIRECTIVES,
                        CHECKBOX_DIRECTIVES,
                        CODE_HIGHLIGHT_DIRECTIVES,
                        DATAGRID_DIRECTIVES,
                        DROPDOWN_DIRECTIVES,
                        LAYOUT_DIRECTIVES,
                        MODAL_DIRECTIVES,
                        NAVIGATION_DIRECTIVES,
                        STACK_VIEW_DIRECTIVES,
                        TABS_DIRECTIVES,
                        TREE_VIEW_DIRECTIVES,
                        WIZARD_DIRECTIVES,
                        ICON_DIRECTIVES
                    ]
                } ] } ];
    /** @nocollapse */
    ClarityModule.ctorParameters = function () { return []; };
    return ClarityModule;
}());

function collapse() {
    "use strict";
    return [
        _angular_core.state("true", _angular_core.style({
            "height": 0,
            "overflow-y": "hidden"
        })),
        _angular_core.transition("true => false", [
            _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                "height": "*",
                "overflow-y": "hidden"
            }))
        ]),
        _angular_core.transition("false => true", [
            _angular_core.style({
                "height": "*",
                "overflow-y": "hidden"
            }),
            _angular_core.animate("0.2s ease-in-out")
        ])
    ];
}

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

function fade(opacity) {
    "use strict";
    if (opacity === void 0) { opacity = 1; }
    return [
        _angular_core.transition("void => *", [
            _angular_core.style({
                opacity: 0
            }),
            _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                opacity: opacity
            }))
        ]),
        _angular_core.transition("* => void", [
            _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                opacity: 0
            }))
        ])
    ];
}

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

function fadeSlide(direction) {
    "use strict";
    var transform = null;
    if (direction === "up") {
        transform = "translate(0, 25%)";
    }
    else if (direction === "down") {
        transform = "translate(0, -25%)";
    }
    else if (direction === "left") {
        transform = "translate(25%, 0)";
    }
    else if (direction === "right") {
        transform = "translate(-25%, 0)";
    }
    else {
        throw new Error("Unknown direction " + direction + " for slide animation.");
    }
    return [
        _angular_core.transition("void => *", [
            _angular_core.style({
                opacity: 0,
                transform: transform
            }),
            _angular_core.animate("0.2s ease-in-out")]),
        _angular_core.transition("* => void", [
            _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                opacity: 0,
                transform: transform
            }))])
    ];
}

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

function slide(direction) {
    "use strict";
    var transform = null;
    if (direction === "up") {
        transform = "translate(0, 25%)";
    }
    else if (direction === "down") {
        transform = "translate(0, -25%)";
    }
    else if (direction === "left") {
        transform = "translate(25%, 0)";
    }
    else if (direction === "right") {
        transform = "translate(-25%, 0)";
    }
    else {
        throw new Error("Unknown direction " + direction + " for slide animation.");
    }
    return [
        _angular_core.transition("void => *", [
            _angular_core.style({
                transform: transform
            }),
            _angular_core.animate("0.2s ease-in-out")]),
        _angular_core.transition("* => void", [
            _angular_core.animate("0.2s ease-in-out", _angular_core.style({
                transform: transform
            }))])
    ];
}

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

/*
 * Copyright (c) 2016 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */

exports.ClarityModule = ClarityModule;
exports.ALERT_DIRECTIVES = ALERT_DIRECTIVES;
exports.Alert = Alert;
exports.CHECKBOX_DIRECTIVES = CHECKBOX_DIRECTIVES;
exports.Checkbox = Checkbox;
exports.CODE_HIGHLIGHT_DIRECTIVES = CODE_HIGHLIGHT_DIRECTIVES;
exports.CodeHighlight = CodeHighlight;
exports.DROPDOWN_DIRECTIVES = DROPDOWN_DIRECTIVES;
exports.Dropdown = Dropdown;
exports.DropdownToggle = DropdownToggle;
exports.DropdownItem = DropdownItem;
exports.DATAGRID_DIRECTIVES = DATAGRID_DIRECTIVES;
exports.Datagrid = Datagrid;
exports.DatagridActionBar = DatagridActionBar;
exports.DatagridActionOverflow = DatagridActionOverflow;
exports.DatagridColumn = DatagridColumn;
exports.DatagridFilter = DatagridFilter;
exports.DatagridItems = DatagridItems;
exports.DatagridRow = DatagridRow;
exports.DatagridCell = DatagridCell;
exports.DatagridFooter = DatagridFooter;
exports.DatagridPagination = DatagridPagination;
exports.DatagridPlaceholder = DatagridPlaceholder;
exports.DatagridStringFilter = DatagridStringFilter;
exports.DatagridPropertyStringFilter = DatagridPropertyStringFilter;
exports.DatagridPropertyComparator = DatagridPropertyComparator;
exports.ICON_DIRECTIVES = ICON_DIRECTIVES;
exports.LAYOUT_DIRECTIVES = LAYOUT_DIRECTIVES;
exports.MainContainer = MainContainer;
exports.MODAL_DIRECTIVES = MODAL_DIRECTIVES;
exports.Modal = Modal;
exports.NAVIGATION_DIRECTIVES = NAVIGATION_DIRECTIVES;
exports.Header = Header;
exports.NavLevelDirective = NavLevelDirective;
exports.STACK_VIEW_DIRECTIVES = STACK_VIEW_DIRECTIVES;
exports.StackView = StackView;
exports.StackViewCustomTags = StackViewCustomTags;
exports.StackHeader = StackHeader;
exports.StackBlock = StackBlock;
exports.StackInput = StackInput;
exports.StackSelect = StackSelect;
exports.TABS_DIRECTIVES = TABS_DIRECTIVES;
exports.Tabs = Tabs;
exports.TabContent = TabContent;
exports.TabLink = TabLink;
exports.WIZARD_DIRECTIVES = WIZARD_DIRECTIVES;
exports.Wizard = Wizard;
exports.WizardStep = WizardStep;
exports.WizardPage = WizardPage;
exports.collapse = collapse;
exports.fade = fade;
exports.fadeSlide = fadeSlide;
exports.slide = slide;

Object.defineProperty(exports, '__esModule', { value: true });

})));
